// Code generated by ffjson <https://github.com/pquerna/ffjson>. DO NOT EDIT.
// source: attr.pb.go

package pbuf

import (
	"bytes"
	"errors"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

// MarshalJSON marshal bytes to json - template
func (j *ChemblActivity) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChemblActivity) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.Type) != 0 {
		buf.WriteString(`"type":`)
		fflib.WriteJsonString(buf, string(j.Type))
		buf.WriteByte(',')
	}
	if len(j.Relation) != 0 {
		buf.WriteString(`"relation":`)
		fflib.WriteJsonString(buf, string(j.Relation))
		buf.WriteByte(',')
	}
	if j.Value != 0 {
		buf.WriteString(`"value":`)
		fflib.AppendFloat(buf, float64(j.Value), 'g', -1, 64)
		buf.WriteByte(',')
	}
	if len(j.Units) != 0 {
		buf.WriteString(`"units":`)
		fflib.WriteJsonString(buf, string(j.Units))
		buf.WriteByte(',')
	}
	if len(j.StandardType) != 0 {
		buf.WriteString(`"standardType":`)
		fflib.WriteJsonString(buf, string(j.StandardType))
		buf.WriteByte(',')
	}
	if len(j.StandardRelation) != 0 {
		buf.WriteString(`"standardRelation":`)
		fflib.WriteJsonString(buf, string(j.StandardRelation))
		buf.WriteByte(',')
	}
	if j.StandardValue != 0 {
		buf.WriteString(`"standardValue":`)
		fflib.AppendFloat(buf, float64(j.StandardValue), 'g', -1, 64)
		buf.WriteByte(',')
	}
	if len(j.StandardUnits) != 0 {
		buf.WriteString(`"standardUnits":`)
		fflib.WriteJsonString(buf, string(j.StandardUnits))
		buf.WriteByte(',')
	}
	if len(j.DataValidityIssue) != 0 {
		buf.WriteString(`"dataValidityIssue":`)
		fflib.WriteJsonString(buf, string(j.DataValidityIssue))
		buf.WriteByte(',')
	}
	if len(j.DataValidityComment) != 0 {
		buf.WriteString(`"dataValidityComment":`)
		fflib.WriteJsonString(buf, string(j.DataValidityComment))
		buf.WriteByte(',')
	}
	if j.PChembl != 0 {
		buf.WriteString(`"pChembl":`)
		fflib.AppendFloat(buf, float64(j.PChembl), 'g', -1, 64)
		buf.WriteByte(',')
	}
	if len(j.ActivityComment) != 0 {
		buf.WriteString(`"activityComment":`)
		fflib.WriteJsonString(buf, string(j.ActivityComment))
		buf.WriteByte(',')
	}
	if len(j.PotentialDuplicate) != 0 {
		buf.WriteString(`"potentialDuplicate":`)
		fflib.WriteJsonString(buf, string(j.PotentialDuplicate))
		buf.WriteByte(',')
	}
	if len(j.Bao) != 0 {
		buf.WriteString(`"bao":`)
		fflib.WriteJsonString(buf, string(j.Bao))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChemblActivitybase = iota
	ffjtChemblActivitynosuchkey

	ffjtChemblActivityType

	ffjtChemblActivityRelation

	ffjtChemblActivityValue

	ffjtChemblActivityUnits

	ffjtChemblActivityStandardType

	ffjtChemblActivityStandardRelation

	ffjtChemblActivityStandardValue

	ffjtChemblActivityStandardUnits

	ffjtChemblActivityDataValidityIssue

	ffjtChemblActivityDataValidityComment

	ffjtChemblActivityPChembl

	ffjtChemblActivityActivityComment

	ffjtChemblActivityPotentialDuplicate

	ffjtChemblActivityBao
)

var ffjKeyChemblActivityType = []byte("type")

var ffjKeyChemblActivityRelation = []byte("relation")

var ffjKeyChemblActivityValue = []byte("value")

var ffjKeyChemblActivityUnits = []byte("units")

var ffjKeyChemblActivityStandardType = []byte("standardType")

var ffjKeyChemblActivityStandardRelation = []byte("standardRelation")

var ffjKeyChemblActivityStandardValue = []byte("standardValue")

var ffjKeyChemblActivityStandardUnits = []byte("standardUnits")

var ffjKeyChemblActivityDataValidityIssue = []byte("dataValidityIssue")

var ffjKeyChemblActivityDataValidityComment = []byte("dataValidityComment")

var ffjKeyChemblActivityPChembl = []byte("pChembl")

var ffjKeyChemblActivityActivityComment = []byte("activityComment")

var ffjKeyChemblActivityPotentialDuplicate = []byte("potentialDuplicate")

var ffjKeyChemblActivityBao = []byte("bao")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChemblActivity) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChemblActivity) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChemblActivitybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChemblActivitynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyChemblActivityActivityComment, kn) {
						currentKey = ffjtChemblActivityActivityComment
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'b':

					if bytes.Equal(ffjKeyChemblActivityBao, kn) {
						currentKey = ffjtChemblActivityBao
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyChemblActivityDataValidityIssue, kn) {
						currentKey = ffjtChemblActivityDataValidityIssue
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblActivityDataValidityComment, kn) {
						currentKey = ffjtChemblActivityDataValidityComment
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyChemblActivityPChembl, kn) {
						currentKey = ffjtChemblActivityPChembl
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblActivityPotentialDuplicate, kn) {
						currentKey = ffjtChemblActivityPotentialDuplicate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyChemblActivityRelation, kn) {
						currentKey = ffjtChemblActivityRelation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyChemblActivityStandardType, kn) {
						currentKey = ffjtChemblActivityStandardType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblActivityStandardRelation, kn) {
						currentKey = ffjtChemblActivityStandardRelation
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblActivityStandardValue, kn) {
						currentKey = ffjtChemblActivityStandardValue
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblActivityStandardUnits, kn) {
						currentKey = ffjtChemblActivityStandardUnits
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyChemblActivityType, kn) {
						currentKey = ffjtChemblActivityType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyChemblActivityUnits, kn) {
						currentKey = ffjtChemblActivityUnits
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyChemblActivityValue, kn) {
						currentKey = ffjtChemblActivityValue
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblActivityBao, kn) {
					currentKey = ffjtChemblActivityBao
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblActivityPotentialDuplicate, kn) {
					currentKey = ffjtChemblActivityPotentialDuplicate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblActivityActivityComment, kn) {
					currentKey = ffjtChemblActivityActivityComment
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblActivityPChembl, kn) {
					currentKey = ffjtChemblActivityPChembl
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblActivityDataValidityComment, kn) {
					currentKey = ffjtChemblActivityDataValidityComment
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblActivityDataValidityIssue, kn) {
					currentKey = ffjtChemblActivityDataValidityIssue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblActivityStandardUnits, kn) {
					currentKey = ffjtChemblActivityStandardUnits
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblActivityStandardValue, kn) {
					currentKey = ffjtChemblActivityStandardValue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblActivityStandardRelation, kn) {
					currentKey = ffjtChemblActivityStandardRelation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblActivityStandardType, kn) {
					currentKey = ffjtChemblActivityStandardType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblActivityUnits, kn) {
					currentKey = ffjtChemblActivityUnits
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblActivityValue, kn) {
					currentKey = ffjtChemblActivityValue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblActivityRelation, kn) {
					currentKey = ffjtChemblActivityRelation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblActivityType, kn) {
					currentKey = ffjtChemblActivityType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChemblActivitynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChemblActivityType:
					goto handle_Type

				case ffjtChemblActivityRelation:
					goto handle_Relation

				case ffjtChemblActivityValue:
					goto handle_Value

				case ffjtChemblActivityUnits:
					goto handle_Units

				case ffjtChemblActivityStandardType:
					goto handle_StandardType

				case ffjtChemblActivityStandardRelation:
					goto handle_StandardRelation

				case ffjtChemblActivityStandardValue:
					goto handle_StandardValue

				case ffjtChemblActivityStandardUnits:
					goto handle_StandardUnits

				case ffjtChemblActivityDataValidityIssue:
					goto handle_DataValidityIssue

				case ffjtChemblActivityDataValidityComment:
					goto handle_DataValidityComment

				case ffjtChemblActivityPChembl:
					goto handle_PChembl

				case ffjtChemblActivityActivityComment:
					goto handle_ActivityComment

				case ffjtChemblActivityPotentialDuplicate:
					goto handle_PotentialDuplicate

				case ffjtChemblActivityBao:
					goto handle_Bao

				case ffjtChemblActivitynosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Relation:

	/* handler: j.Relation type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Relation = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Value:

	/* handler: j.Value type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Value = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Units:

	/* handler: j.Units type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Units = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StandardType:

	/* handler: j.StandardType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.StandardType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StandardRelation:

	/* handler: j.StandardRelation type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.StandardRelation = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StandardValue:

	/* handler: j.StandardValue type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.StandardValue = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StandardUnits:

	/* handler: j.StandardUnits type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.StandardUnits = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DataValidityIssue:

	/* handler: j.DataValidityIssue type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.DataValidityIssue = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DataValidityComment:

	/* handler: j.DataValidityComment type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.DataValidityComment = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PChembl:

	/* handler: j.PChembl type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.PChembl = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ActivityComment:

	/* handler: j.ActivityComment type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ActivityComment = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PotentialDuplicate:

	/* handler: j.PotentialDuplicate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PotentialDuplicate = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Bao:

	/* handler: j.Bao type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Bao = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChemblAssay) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChemblAssay) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.Desc) != 0 {
		buf.WriteString(`"desc":`)
		fflib.WriteJsonString(buf, string(j.Desc))
		buf.WriteByte(',')
	}
	if len(j.Type) != 0 {
		buf.WriteString(`"type":`)
		fflib.WriteJsonString(buf, string(j.Type))
		buf.WriteByte(',')
	}
	if len(j.TargetConfDesc) != 0 {
		buf.WriteString(`"targetConfDesc":`)
		fflib.WriteJsonString(buf, string(j.TargetConfDesc))
		buf.WriteByte(',')
	}
	if len(j.TargetRelType) != 0 {
		buf.WriteString(`"targetRelType":`)
		fflib.WriteJsonString(buf, string(j.TargetRelType))
		buf.WriteByte(',')
	}
	if len(j.TargetRelDesc) != 0 {
		buf.WriteString(`"targetRelDesc":`)
		fflib.WriteJsonString(buf, string(j.TargetRelDesc))
		buf.WriteByte(',')
	}
	if j.TargetConfScore != 0 {
		buf.WriteString(`"targetConfScore":`)
		fflib.FormatBits2(buf, uint64(j.TargetConfScore), 10, j.TargetConfScore < 0)
		buf.WriteByte(',')
	}
	if len(j.SubCellFrac) != 0 {
		buf.WriteString(`"subCellFrac":`)
		fflib.WriteJsonString(buf, string(j.SubCellFrac))
		buf.WriteByte(',')
	}
	if len(j.TestType) != 0 {
		buf.WriteString(`"testType":`)
		fflib.WriteJsonString(buf, string(j.TestType))
		buf.WriteByte(',')
	}
	if len(j.Strain) != 0 {
		buf.WriteString(`"strain":`)
		fflib.WriteJsonString(buf, string(j.Strain))
		buf.WriteByte(',')
	}
	if len(j.CellType) != 0 {
		buf.WriteString(`"cellType":`)
		fflib.WriteJsonString(buf, string(j.CellType))
		buf.WriteByte(',')
	}
	if len(j.Tissue) != 0 {
		buf.WriteString(`"tissue":`)
		fflib.WriteJsonString(buf, string(j.Tissue))
		buf.WriteByte(',')
	}
	if len(j.Tax) != 0 {
		buf.WriteString(`"tax":`)
		fflib.WriteJsonString(buf, string(j.Tax))
		buf.WriteByte(',')
	}
	if len(j.Category) != 0 {
		buf.WriteString(`"category":`)
		fflib.WriteJsonString(buf, string(j.Category))
		buf.WriteByte(',')
	}
	if len(j.Source) != 0 {
		buf.WriteString(`"source":`)
		fflib.WriteJsonString(buf, string(j.Source))
		buf.WriteByte(',')
	}
	if len(j.SourceDesc) != 0 {
		buf.WriteString(`"sourceDesc":`)
		fflib.WriteJsonString(buf, string(j.SourceDesc))
		buf.WriteByte(',')
	}
	if len(j.Bao) != 0 {
		buf.WriteString(`"bao":`)
		fflib.WriteJsonString(buf, string(j.Bao))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChemblAssaybase = iota
	ffjtChemblAssaynosuchkey

	ffjtChemblAssayDesc

	ffjtChemblAssayType

	ffjtChemblAssayTargetConfDesc

	ffjtChemblAssayTargetRelType

	ffjtChemblAssayTargetRelDesc

	ffjtChemblAssayTargetConfScore

	ffjtChemblAssaySubCellFrac

	ffjtChemblAssayTestType

	ffjtChemblAssayStrain

	ffjtChemblAssayCellType

	ffjtChemblAssayTissue

	ffjtChemblAssayTax

	ffjtChemblAssayCategory

	ffjtChemblAssaySource

	ffjtChemblAssaySourceDesc

	ffjtChemblAssayBao
)

var ffjKeyChemblAssayDesc = []byte("desc")

var ffjKeyChemblAssayType = []byte("type")

var ffjKeyChemblAssayTargetConfDesc = []byte("targetConfDesc")

var ffjKeyChemblAssayTargetRelType = []byte("targetRelType")

var ffjKeyChemblAssayTargetRelDesc = []byte("targetRelDesc")

var ffjKeyChemblAssayTargetConfScore = []byte("targetConfScore")

var ffjKeyChemblAssaySubCellFrac = []byte("subCellFrac")

var ffjKeyChemblAssayTestType = []byte("testType")

var ffjKeyChemblAssayStrain = []byte("strain")

var ffjKeyChemblAssayCellType = []byte("cellType")

var ffjKeyChemblAssayTissue = []byte("tissue")

var ffjKeyChemblAssayTax = []byte("tax")

var ffjKeyChemblAssayCategory = []byte("category")

var ffjKeyChemblAssaySource = []byte("source")

var ffjKeyChemblAssaySourceDesc = []byte("sourceDesc")

var ffjKeyChemblAssayBao = []byte("bao")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChemblAssay) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChemblAssay) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChemblAssaybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChemblAssaynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffjKeyChemblAssayBao, kn) {
						currentKey = ffjtChemblAssayBao
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyChemblAssayCellType, kn) {
						currentKey = ffjtChemblAssayCellType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblAssayCategory, kn) {
						currentKey = ffjtChemblAssayCategory
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyChemblAssayDesc, kn) {
						currentKey = ffjtChemblAssayDesc
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyChemblAssaySubCellFrac, kn) {
						currentKey = ffjtChemblAssaySubCellFrac
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblAssayStrain, kn) {
						currentKey = ffjtChemblAssayStrain
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblAssaySource, kn) {
						currentKey = ffjtChemblAssaySource
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblAssaySourceDesc, kn) {
						currentKey = ffjtChemblAssaySourceDesc
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyChemblAssayType, kn) {
						currentKey = ffjtChemblAssayType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblAssayTargetConfDesc, kn) {
						currentKey = ffjtChemblAssayTargetConfDesc
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblAssayTargetRelType, kn) {
						currentKey = ffjtChemblAssayTargetRelType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblAssayTargetRelDesc, kn) {
						currentKey = ffjtChemblAssayTargetRelDesc
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblAssayTargetConfScore, kn) {
						currentKey = ffjtChemblAssayTargetConfScore
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblAssayTestType, kn) {
						currentKey = ffjtChemblAssayTestType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblAssayTissue, kn) {
						currentKey = ffjtChemblAssayTissue
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblAssayTax, kn) {
						currentKey = ffjtChemblAssayTax
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblAssayBao, kn) {
					currentKey = ffjtChemblAssayBao
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblAssaySourceDesc, kn) {
					currentKey = ffjtChemblAssaySourceDesc
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblAssaySource, kn) {
					currentKey = ffjtChemblAssaySource
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblAssayCategory, kn) {
					currentKey = ffjtChemblAssayCategory
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblAssayTax, kn) {
					currentKey = ffjtChemblAssayTax
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblAssayTissue, kn) {
					currentKey = ffjtChemblAssayTissue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblAssayCellType, kn) {
					currentKey = ffjtChemblAssayCellType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblAssayStrain, kn) {
					currentKey = ffjtChemblAssayStrain
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblAssayTestType, kn) {
					currentKey = ffjtChemblAssayTestType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblAssaySubCellFrac, kn) {
					currentKey = ffjtChemblAssaySubCellFrac
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblAssayTargetConfScore, kn) {
					currentKey = ffjtChemblAssayTargetConfScore
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblAssayTargetRelDesc, kn) {
					currentKey = ffjtChemblAssayTargetRelDesc
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblAssayTargetRelType, kn) {
					currentKey = ffjtChemblAssayTargetRelType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblAssayTargetConfDesc, kn) {
					currentKey = ffjtChemblAssayTargetConfDesc
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblAssayType, kn) {
					currentKey = ffjtChemblAssayType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblAssayDesc, kn) {
					currentKey = ffjtChemblAssayDesc
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChemblAssaynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChemblAssayDesc:
					goto handle_Desc

				case ffjtChemblAssayType:
					goto handle_Type

				case ffjtChemblAssayTargetConfDesc:
					goto handle_TargetConfDesc

				case ffjtChemblAssayTargetRelType:
					goto handle_TargetRelType

				case ffjtChemblAssayTargetRelDesc:
					goto handle_TargetRelDesc

				case ffjtChemblAssayTargetConfScore:
					goto handle_TargetConfScore

				case ffjtChemblAssaySubCellFrac:
					goto handle_SubCellFrac

				case ffjtChemblAssayTestType:
					goto handle_TestType

				case ffjtChemblAssayStrain:
					goto handle_Strain

				case ffjtChemblAssayCellType:
					goto handle_CellType

				case ffjtChemblAssayTissue:
					goto handle_Tissue

				case ffjtChemblAssayTax:
					goto handle_Tax

				case ffjtChemblAssayCategory:
					goto handle_Category

				case ffjtChemblAssaySource:
					goto handle_Source

				case ffjtChemblAssaySourceDesc:
					goto handle_SourceDesc

				case ffjtChemblAssayBao:
					goto handle_Bao

				case ffjtChemblAssaynosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Desc:

	/* handler: j.Desc type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Desc = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TargetConfDesc:

	/* handler: j.TargetConfDesc type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.TargetConfDesc = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TargetRelType:

	/* handler: j.TargetRelType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.TargetRelType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TargetRelDesc:

	/* handler: j.TargetRelDesc type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.TargetRelDesc = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TargetConfScore:

	/* handler: j.TargetConfScore type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.TargetConfScore = int32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SubCellFrac:

	/* handler: j.SubCellFrac type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.SubCellFrac = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TestType:

	/* handler: j.TestType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.TestType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Strain:

	/* handler: j.Strain type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Strain = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CellType:

	/* handler: j.CellType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.CellType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tissue:

	/* handler: j.Tissue type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Tissue = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tax:

	/* handler: j.Tax type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Tax = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Category:

	/* handler: j.Category type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Category = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Source:

	/* handler: j.Source type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Source = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SourceDesc:

	/* handler: j.SourceDesc type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.SourceDesc = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Bao:

	/* handler: j.Bao type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Bao = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChemblAttr) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChemblAttr) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if j.Doc != nil {
		if true {
			buf.WriteString(`"doc":`)

			{

				err = j.Doc.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Assay != nil {
		if true {
			buf.WriteString(`"assay":`)

			{

				err = j.Assay.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Activity != nil {
		if true {
			buf.WriteString(`"activity":`)

			{

				err = j.Activity.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Molecule != nil {
		if true {
			buf.WriteString(`"molecule":`)

			{

				err = j.Molecule.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Target != nil {
		if true {
			buf.WriteString(`"target":`)

			{

				err = j.Target.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.TargetComponent != nil {
		if true {
			buf.WriteString(`"targetComponent":`)

			{

				err = j.TargetComponent.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.CellLine != nil {
		if true {
			buf.WriteString(`"cellLine":`)

			{

				err = j.CellLine.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChemblAttrbase = iota
	ffjtChemblAttrnosuchkey

	ffjtChemblAttrDoc

	ffjtChemblAttrAssay

	ffjtChemblAttrActivity

	ffjtChemblAttrMolecule

	ffjtChemblAttrTarget

	ffjtChemblAttrTargetComponent

	ffjtChemblAttrCellLine
)

var ffjKeyChemblAttrDoc = []byte("doc")

var ffjKeyChemblAttrAssay = []byte("assay")

var ffjKeyChemblAttrActivity = []byte("activity")

var ffjKeyChemblAttrMolecule = []byte("molecule")

var ffjKeyChemblAttrTarget = []byte("target")

var ffjKeyChemblAttrTargetComponent = []byte("targetComponent")

var ffjKeyChemblAttrCellLine = []byte("cellLine")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChemblAttr) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChemblAttr) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChemblAttrbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChemblAttrnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyChemblAttrAssay, kn) {
						currentKey = ffjtChemblAttrAssay
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblAttrActivity, kn) {
						currentKey = ffjtChemblAttrActivity
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyChemblAttrCellLine, kn) {
						currentKey = ffjtChemblAttrCellLine
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyChemblAttrDoc, kn) {
						currentKey = ffjtChemblAttrDoc
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyChemblAttrMolecule, kn) {
						currentKey = ffjtChemblAttrMolecule
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyChemblAttrTarget, kn) {
						currentKey = ffjtChemblAttrTarget
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblAttrTargetComponent, kn) {
						currentKey = ffjtChemblAttrTargetComponent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblAttrCellLine, kn) {
					currentKey = ffjtChemblAttrCellLine
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblAttrTargetComponent, kn) {
					currentKey = ffjtChemblAttrTargetComponent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblAttrTarget, kn) {
					currentKey = ffjtChemblAttrTarget
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblAttrMolecule, kn) {
					currentKey = ffjtChemblAttrMolecule
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblAttrActivity, kn) {
					currentKey = ffjtChemblAttrActivity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblAttrAssay, kn) {
					currentKey = ffjtChemblAttrAssay
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblAttrDoc, kn) {
					currentKey = ffjtChemblAttrDoc
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChemblAttrnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChemblAttrDoc:
					goto handle_Doc

				case ffjtChemblAttrAssay:
					goto handle_Assay

				case ffjtChemblAttrActivity:
					goto handle_Activity

				case ffjtChemblAttrMolecule:
					goto handle_Molecule

				case ffjtChemblAttrTarget:
					goto handle_Target

				case ffjtChemblAttrTargetComponent:
					goto handle_TargetComponent

				case ffjtChemblAttrCellLine:
					goto handle_CellLine

				case ffjtChemblAttrnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Doc:

	/* handler: j.Doc type=pbuf.ChemblDocument kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Doc = nil

		} else {

			if j.Doc == nil {
				j.Doc = new(ChemblDocument)
			}

			err = j.Doc.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Assay:

	/* handler: j.Assay type=pbuf.ChemblAssay kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Assay = nil

		} else {

			if j.Assay == nil {
				j.Assay = new(ChemblAssay)
			}

			err = j.Assay.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Activity:

	/* handler: j.Activity type=pbuf.ChemblActivity kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Activity = nil

		} else {

			if j.Activity == nil {
				j.Activity = new(ChemblActivity)
			}

			err = j.Activity.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Molecule:

	/* handler: j.Molecule type=pbuf.ChemblMolecule kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Molecule = nil

		} else {

			if j.Molecule == nil {
				j.Molecule = new(ChemblMolecule)
			}

			err = j.Molecule.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Target:

	/* handler: j.Target type=pbuf.ChemblTarget kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Target = nil

		} else {

			if j.Target == nil {
				j.Target = new(ChemblTarget)
			}

			err = j.Target.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TargetComponent:

	/* handler: j.TargetComponent type=pbuf.ChemblTargetComponent kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.TargetComponent = nil

		} else {

			if j.TargetComponent == nil {
				j.TargetComponent = new(ChemblTargetComponent)
			}

			err = j.TargetComponent.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CellLine:

	/* handler: j.CellLine type=pbuf.ChemblCellLine kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.CellLine = nil

		} else {

			if j.CellLine == nil {
				j.CellLine = new(ChemblCellLine)
			}

			err = j.CellLine.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChemblBindingSite) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChemblBindingSite) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.Name) != 0 {
		buf.WriteString(`"name":`)
		fflib.WriteJsonString(buf, string(j.Name))
		buf.WriteByte(',')
	}
	if j.Mechanism != nil {
		if true {
			buf.WriteString(`"mechanism":`)

			{

				err = j.Mechanism.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChemblBindingSitebase = iota
	ffjtChemblBindingSitenosuchkey

	ffjtChemblBindingSiteName

	ffjtChemblBindingSiteMechanism
)

var ffjKeyChemblBindingSiteName = []byte("name")

var ffjKeyChemblBindingSiteMechanism = []byte("mechanism")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChemblBindingSite) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChemblBindingSite) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChemblBindingSitebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChemblBindingSitenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'm':

					if bytes.Equal(ffjKeyChemblBindingSiteMechanism, kn) {
						currentKey = ffjtChemblBindingSiteMechanism
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyChemblBindingSiteName, kn) {
						currentKey = ffjtChemblBindingSiteName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyChemblBindingSiteMechanism, kn) {
					currentKey = ffjtChemblBindingSiteMechanism
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblBindingSiteName, kn) {
					currentKey = ffjtChemblBindingSiteName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChemblBindingSitenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChemblBindingSiteName:
					goto handle_Name

				case ffjtChemblBindingSiteMechanism:
					goto handle_Mechanism

				case ffjtChemblBindingSitenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mechanism:

	/* handler: j.Mechanism type=pbuf.ChemblMechanism kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Mechanism = nil

		} else {

			if j.Mechanism == nil {
				j.Mechanism = new(ChemblMechanism)
			}

			err = j.Mechanism.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChemblCellLine) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChemblCellLine) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.Desc) != 0 {
		buf.WriteString(`"desc":`)
		fflib.WriteJsonString(buf, string(j.Desc))
		buf.WriteByte(',')
	}
	if len(j.CellosaurusId) != 0 {
		buf.WriteString(`"cellosaurusId":`)
		fflib.WriteJsonString(buf, string(j.CellosaurusId))
		buf.WriteByte(',')
	}
	if len(j.Efo) != 0 {
		buf.WriteString(`"efo":`)
		fflib.WriteJsonString(buf, string(j.Efo))
		buf.WriteByte(',')
	}
	if len(j.Clo) != 0 {
		buf.WriteString(`"clo":`)
		fflib.WriteJsonString(buf, string(j.Clo))
		buf.WriteByte(',')
	}
	if len(j.Tax) != 0 {
		buf.WriteString(`"tax":`)
		fflib.WriteJsonString(buf, string(j.Tax))
		buf.WriteByte(',')
	}
	if len(j.Cellxref) != 0 {
		buf.WriteString(`"cellxref":`)
		if j.Cellxref != nil {
			buf.WriteString(`[`)
			for i, v := range j.Cellxref {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChemblCellLinebase = iota
	ffjtChemblCellLinenosuchkey

	ffjtChemblCellLineDesc

	ffjtChemblCellLineCellosaurusId

	ffjtChemblCellLineEfo

	ffjtChemblCellLineClo

	ffjtChemblCellLineTax

	ffjtChemblCellLineCellxref
)

var ffjKeyChemblCellLineDesc = []byte("desc")

var ffjKeyChemblCellLineCellosaurusId = []byte("cellosaurusId")

var ffjKeyChemblCellLineEfo = []byte("efo")

var ffjKeyChemblCellLineClo = []byte("clo")

var ffjKeyChemblCellLineTax = []byte("tax")

var ffjKeyChemblCellLineCellxref = []byte("cellxref")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChemblCellLine) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChemblCellLine) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChemblCellLinebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChemblCellLinenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyChemblCellLineCellosaurusId, kn) {
						currentKey = ffjtChemblCellLineCellosaurusId
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblCellLineClo, kn) {
						currentKey = ffjtChemblCellLineClo
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblCellLineCellxref, kn) {
						currentKey = ffjtChemblCellLineCellxref
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyChemblCellLineDesc, kn) {
						currentKey = ffjtChemblCellLineDesc
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyChemblCellLineEfo, kn) {
						currentKey = ffjtChemblCellLineEfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyChemblCellLineTax, kn) {
						currentKey = ffjtChemblCellLineTax
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblCellLineCellxref, kn) {
					currentKey = ffjtChemblCellLineCellxref
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblCellLineTax, kn) {
					currentKey = ffjtChemblCellLineTax
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblCellLineClo, kn) {
					currentKey = ffjtChemblCellLineClo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblCellLineEfo, kn) {
					currentKey = ffjtChemblCellLineEfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblCellLineCellosaurusId, kn) {
					currentKey = ffjtChemblCellLineCellosaurusId
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblCellLineDesc, kn) {
					currentKey = ffjtChemblCellLineDesc
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChemblCellLinenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChemblCellLineDesc:
					goto handle_Desc

				case ffjtChemblCellLineCellosaurusId:
					goto handle_CellosaurusId

				case ffjtChemblCellLineEfo:
					goto handle_Efo

				case ffjtChemblCellLineClo:
					goto handle_Clo

				case ffjtChemblCellLineTax:
					goto handle_Tax

				case ffjtChemblCellLineCellxref:
					goto handle_Cellxref

				case ffjtChemblCellLinenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Desc:

	/* handler: j.Desc type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Desc = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CellosaurusId:

	/* handler: j.CellosaurusId type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.CellosaurusId = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Efo:

	/* handler: j.Efo type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Efo = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Clo:

	/* handler: j.Clo type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Clo = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tax:

	/* handler: j.Tax type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Tax = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Cellxref:

	/* handler: j.Cellxref type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Cellxref = nil
		} else {

			j.Cellxref = []string{}

			wantVal := true

			for {

				var tmpJCellxref string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJCellxref type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJCellxref = string(string(outBuf))

					}
				}

				j.Cellxref = append(j.Cellxref, tmpJCellxref)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChemblDocument) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChemblDocument) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.Title) != 0 {
		buf.WriteString(`"title":`)
		fflib.WriteJsonString(buf, string(j.Title))
		buf.WriteByte(',')
	}
	if len(j.Type) != 0 {
		buf.WriteString(`"type":`)
		fflib.WriteJsonString(buf, string(j.Type))
		buf.WriteByte(',')
	}
	if len(j.Journal) != 0 {
		buf.WriteString(`"journal":`)
		fflib.WriteJsonString(buf, string(j.Journal))
		buf.WriteByte(',')
	}
	if len(j.JournalShortName) != 0 {
		buf.WriteString(`"journalShortName":`)
		fflib.WriteJsonString(buf, string(j.JournalShortName))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChemblDocumentbase = iota
	ffjtChemblDocumentnosuchkey

	ffjtChemblDocumentTitle

	ffjtChemblDocumentType

	ffjtChemblDocumentJournal

	ffjtChemblDocumentJournalShortName
)

var ffjKeyChemblDocumentTitle = []byte("title")

var ffjKeyChemblDocumentType = []byte("type")

var ffjKeyChemblDocumentJournal = []byte("journal")

var ffjKeyChemblDocumentJournalShortName = []byte("journalShortName")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChemblDocument) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChemblDocument) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChemblDocumentbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChemblDocumentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'j':

					if bytes.Equal(ffjKeyChemblDocumentJournal, kn) {
						currentKey = ffjtChemblDocumentJournal
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblDocumentJournalShortName, kn) {
						currentKey = ffjtChemblDocumentJournalShortName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyChemblDocumentTitle, kn) {
						currentKey = ffjtChemblDocumentTitle
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblDocumentType, kn) {
						currentKey = ffjtChemblDocumentType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyChemblDocumentJournalShortName, kn) {
					currentKey = ffjtChemblDocumentJournalShortName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblDocumentJournal, kn) {
					currentKey = ffjtChemblDocumentJournal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblDocumentType, kn) {
					currentKey = ffjtChemblDocumentType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblDocumentTitle, kn) {
					currentKey = ffjtChemblDocumentTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChemblDocumentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChemblDocumentTitle:
					goto handle_Title

				case ffjtChemblDocumentType:
					goto handle_Type

				case ffjtChemblDocumentJournal:
					goto handle_Journal

				case ffjtChemblDocumentJournalShortName:
					goto handle_JournalShortName

				case ffjtChemblDocumentnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Journal:

	/* handler: j.Journal type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Journal = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_JournalShortName:

	/* handler: j.JournalShortName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.JournalShortName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChemblIndication) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChemblIndication) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.EfoName) != 0 {
		buf.WriteString(`"efoName":`)
		fflib.WriteJsonString(buf, string(j.EfoName))
		buf.WriteByte(',')
	}
	if len(j.MeshHeading) != 0 {
		buf.WriteString(`"meshHeading":`)
		fflib.WriteJsonString(buf, string(j.MeshHeading))
		buf.WriteByte(',')
	}
	if j.HighestDevelopmentPhase != 0 {
		buf.WriteString(`"highestDevelopmentPhase":`)
		fflib.FormatBits2(buf, uint64(j.HighestDevelopmentPhase), 10, j.HighestDevelopmentPhase < 0)
		buf.WriteByte(',')
	}
	if len(j.Efo) != 0 {
		buf.WriteString(`"efo":`)
		fflib.WriteJsonString(buf, string(j.Efo))
		buf.WriteByte(',')
	}
	if len(j.Mesh) != 0 {
		buf.WriteString(`"mesh":`)
		fflib.WriteJsonString(buf, string(j.Mesh))
		buf.WriteByte(',')
	}
	if j.Mechanism != nil {
		if true {
			buf.WriteString(`"mechanism":`)

			{

				err = j.Mechanism.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChemblIndicationbase = iota
	ffjtChemblIndicationnosuchkey

	ffjtChemblIndicationEfoName

	ffjtChemblIndicationMeshHeading

	ffjtChemblIndicationHighestDevelopmentPhase

	ffjtChemblIndicationEfo

	ffjtChemblIndicationMesh

	ffjtChemblIndicationMechanism
)

var ffjKeyChemblIndicationEfoName = []byte("efoName")

var ffjKeyChemblIndicationMeshHeading = []byte("meshHeading")

var ffjKeyChemblIndicationHighestDevelopmentPhase = []byte("highestDevelopmentPhase")

var ffjKeyChemblIndicationEfo = []byte("efo")

var ffjKeyChemblIndicationMesh = []byte("mesh")

var ffjKeyChemblIndicationMechanism = []byte("mechanism")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChemblIndication) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChemblIndication) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChemblIndicationbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChemblIndicationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'e':

					if bytes.Equal(ffjKeyChemblIndicationEfoName, kn) {
						currentKey = ffjtChemblIndicationEfoName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblIndicationEfo, kn) {
						currentKey = ffjtChemblIndicationEfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyChemblIndicationHighestDevelopmentPhase, kn) {
						currentKey = ffjtChemblIndicationHighestDevelopmentPhase
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyChemblIndicationMeshHeading, kn) {
						currentKey = ffjtChemblIndicationMeshHeading
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblIndicationMesh, kn) {
						currentKey = ffjtChemblIndicationMesh
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblIndicationMechanism, kn) {
						currentKey = ffjtChemblIndicationMechanism
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyChemblIndicationMechanism, kn) {
					currentKey = ffjtChemblIndicationMechanism
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblIndicationMesh, kn) {
					currentKey = ffjtChemblIndicationMesh
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblIndicationEfo, kn) {
					currentKey = ffjtChemblIndicationEfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblIndicationHighestDevelopmentPhase, kn) {
					currentKey = ffjtChemblIndicationHighestDevelopmentPhase
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblIndicationMeshHeading, kn) {
					currentKey = ffjtChemblIndicationMeshHeading
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblIndicationEfoName, kn) {
					currentKey = ffjtChemblIndicationEfoName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChemblIndicationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChemblIndicationEfoName:
					goto handle_EfoName

				case ffjtChemblIndicationMeshHeading:
					goto handle_MeshHeading

				case ffjtChemblIndicationHighestDevelopmentPhase:
					goto handle_HighestDevelopmentPhase

				case ffjtChemblIndicationEfo:
					goto handle_Efo

				case ffjtChemblIndicationMesh:
					goto handle_Mesh

				case ffjtChemblIndicationMechanism:
					goto handle_Mechanism

				case ffjtChemblIndicationnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_EfoName:

	/* handler: j.EfoName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.EfoName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MeshHeading:

	/* handler: j.MeshHeading type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MeshHeading = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HighestDevelopmentPhase:

	/* handler: j.HighestDevelopmentPhase type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.HighestDevelopmentPhase = int32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Efo:

	/* handler: j.Efo type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Efo = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mesh:

	/* handler: j.Mesh type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Mesh = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mechanism:

	/* handler: j.Mechanism type=pbuf.ChemblMechanism kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Mechanism = nil

		} else {

			if j.Mechanism == nil {
				j.Mechanism = new(ChemblMechanism)
			}

			err = j.Mechanism.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChemblMechanism) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChemblMechanism) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.Desc) != 0 {
		buf.WriteString(`"desc":`)
		fflib.WriteJsonString(buf, string(j.Desc))
		buf.WriteByte(',')
	}
	if len(j.Action) != 0 {
		buf.WriteString(`"action":`)
		fflib.WriteJsonString(buf, string(j.Action))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChemblMechanismbase = iota
	ffjtChemblMechanismnosuchkey

	ffjtChemblMechanismDesc

	ffjtChemblMechanismAction
)

var ffjKeyChemblMechanismDesc = []byte("desc")

var ffjKeyChemblMechanismAction = []byte("action")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChemblMechanism) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChemblMechanism) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChemblMechanismbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChemblMechanismnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyChemblMechanismAction, kn) {
						currentKey = ffjtChemblMechanismAction
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyChemblMechanismDesc, kn) {
						currentKey = ffjtChemblMechanismDesc
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblMechanismAction, kn) {
					currentKey = ffjtChemblMechanismAction
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblMechanismDesc, kn) {
					currentKey = ffjtChemblMechanismDesc
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChemblMechanismnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChemblMechanismDesc:
					goto handle_Desc

				case ffjtChemblMechanismAction:
					goto handle_Action

				case ffjtChemblMechanismnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Desc:

	/* handler: j.Desc type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Desc = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Action:

	/* handler: j.Action type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Action = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChemblMolecule) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChemblMolecule) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.Desc) != 0 {
		buf.WriteString(`"desc":`)
		fflib.WriteJsonString(buf, string(j.Desc))
		buf.WriteByte(',')
	}
	if j.HighestDevelopmentPhase != 0 {
		buf.WriteString(`"highestDevelopmentPhase":`)
		fflib.FormatBits2(buf, uint64(j.HighestDevelopmentPhase), 10, j.HighestDevelopmentPhase < 0)
		buf.WriteByte(',')
	}
	if len(j.AltNames) != 0 {
		buf.WriteString(`"altNames":`)
		if j.AltNames != nil {
			buf.WriteString(`[`)
			for i, v := range j.AltNames {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.AtcClassification) != 0 {
		buf.WriteString(`"atcClassification":`)
		if j.AtcClassification != nil {
			buf.WriteString(`[`)
			for i, v := range j.AtcClassification {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.IsBiotherapeutic) != 0 {
		buf.WriteString(`"isBiotherapeutic":`)
		fflib.WriteJsonString(buf, string(j.IsBiotherapeutic))
		buf.WriteByte(',')
	}
	if len(j.HelmNotation) != 0 {
		buf.WriteString(`"helmNotation":`)
		fflib.WriteJsonString(buf, string(j.HelmNotation))
		buf.WriteByte(',')
	}
	if len(j.HracClassification) != 0 {
		buf.WriteString(`"hracClassification":`)
		fflib.WriteJsonString(buf, string(j.HracClassification))
		buf.WriteByte(',')
	}
	if len(j.FracClassification) != 0 {
		buf.WriteString(`"fracClassification":`)
		fflib.WriteJsonString(buf, string(j.FracClassification))
		buf.WriteByte(',')
	}
	if len(j.IracClassification) != 0 {
		buf.WriteString(`"iracClassification":`)
		fflib.WriteJsonString(buf, string(j.IracClassification))
		buf.WriteByte(',')
	}
	if len(j.Type) != 0 {
		buf.WriteString(`"type":`)
		fflib.WriteJsonString(buf, string(j.Type))
		buf.WriteByte(',')
	}
	if len(j.BioComponentType) != 0 {
		buf.WriteString(`"bioComponentType":`)
		fflib.WriteJsonString(buf, string(j.BioComponentType))
		buf.WriteByte(',')
	}
	if len(j.BioComponentDescription) != 0 {
		buf.WriteString(`"bioComponentDescription":`)
		fflib.WriteJsonString(buf, string(j.BioComponentDescription))
		buf.WriteByte(',')
	}
	if len(j.BioComponentSquence) != 0 {
		buf.WriteString(`"bioComponentSquence":`)
		fflib.WriteJsonString(buf, string(j.BioComponentSquence))
		buf.WriteByte(',')
	}
	if len(j.BioComponentTaxo) != 0 {
		buf.WriteString(`"bioComponentTaxo":`)
		fflib.WriteJsonString(buf, string(j.BioComponentTaxo))
		buf.WriteByte(',')
	}
	if len(j.Indications) != 0 {
		buf.WriteString(`"indications":`)
		if j.Indications != nil {
			buf.WriteString(`[`)
			for i, v := range j.Indications {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
					} else {

						err = v.MarshalJSONBuf(buf)
						if err != nil {
							return err
						}

					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Parent) != 0 {
		buf.WriteString(`"parent":`)
		fflib.WriteJsonString(buf, string(j.Parent))
		buf.WriteByte(',')
	}
	if len(j.Childs) != 0 {
		buf.WriteString(`"childs":`)
		if j.Childs != nil {
			buf.WriteString(`[`)
			for i, v := range j.Childs {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if j.Mechanism != nil {
		if true {
			buf.WriteString(`"mechanism":`)

			{

				err = j.Mechanism.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.Inchi) != 0 {
		buf.WriteString(`"inchi":`)
		fflib.WriteJsonString(buf, string(j.Inchi))
		buf.WriteByte(',')
	}
	if len(j.Name) != 0 {
		buf.WriteString(`"name":`)
		fflib.WriteJsonString(buf, string(j.Name))
		buf.WriteByte(',')
	}
	if len(j.InchiKey) != 0 {
		buf.WriteString(`"inchiKey":`)
		fflib.WriteJsonString(buf, string(j.InchiKey))
		buf.WriteByte(',')
	}
	if len(j.Smiles) != 0 {
		buf.WriteString(`"smiles":`)
		fflib.WriteJsonString(buf, string(j.Smiles))
		buf.WriteByte(',')
	}
	if j.Alogp != 0 {
		buf.WriteString(`"alogp":`)
		fflib.AppendFloat(buf, float64(j.Alogp), 'g', -1, 64)
		buf.WriteByte(',')
	}
	if j.WeightFreebase != 0 {
		buf.WriteString(`"weightFreebase":`)
		fflib.AppendFloat(buf, float64(j.WeightFreebase), 'g', -1, 64)
		buf.WriteByte(',')
	}
	if j.Hba != 0 {
		buf.WriteString(`"hba":`)
		fflib.AppendFloat(buf, float64(j.Hba), 'g', -1, 64)
		buf.WriteByte(',')
	}
	if j.Hbd != 0 {
		buf.WriteString(`"hbd":`)
		fflib.AppendFloat(buf, float64(j.Hbd), 'g', -1, 64)
		buf.WriteByte(',')
	}
	if j.Psa != 0 {
		buf.WriteString(`"psa":`)
		fflib.AppendFloat(buf, float64(j.Psa), 'g', -1, 64)
		buf.WriteByte(',')
	}
	if j.Rtb != 0 {
		buf.WriteString(`"rtb":`)
		fflib.AppendFloat(buf, float64(j.Rtb), 'g', -1, 64)
		buf.WriteByte(',')
	}
	if len(j.Ro3Pass) != 0 {
		buf.WriteString(`"ro3Pass":`)
		fflib.WriteJsonString(buf, string(j.Ro3Pass))
		buf.WriteByte(',')
	}
	if j.NumRo5Violations != 0 {
		buf.WriteString(`"numRo5Violations":`)
		fflib.AppendFloat(buf, float64(j.NumRo5Violations), 'g', -1, 64)
		buf.WriteByte(',')
	}
	if j.AcdMostApka != 0 {
		buf.WriteString(`"acdMostApka":`)
		fflib.AppendFloat(buf, float64(j.AcdMostApka), 'g', -1, 64)
		buf.WriteByte(',')
	}
	if j.AcdMostBpka != 0 {
		buf.WriteString(`"acdMostBpka":`)
		fflib.AppendFloat(buf, float64(j.AcdMostBpka), 'g', -1, 64)
		buf.WriteByte(',')
	}
	if j.AcdLogp != 0 {
		buf.WriteString(`"acdLogp":`)
		fflib.AppendFloat(buf, float64(j.AcdLogp), 'g', -1, 64)
		buf.WriteByte(',')
	}
	if j.AcdLogd != 0 {
		buf.WriteString(`"acdLogd":`)
		fflib.AppendFloat(buf, float64(j.AcdLogd), 'g', -1, 64)
		buf.WriteByte(',')
	}
	if len(j.MolecularSpecies) != 0 {
		buf.WriteString(`"molecularSpecies":`)
		fflib.WriteJsonString(buf, string(j.MolecularSpecies))
		buf.WriteByte(',')
	}
	if j.Weight != 0 {
		buf.WriteString(`"weight":`)
		fflib.AppendFloat(buf, float64(j.Weight), 'g', -1, 64)
		buf.WriteByte(',')
	}
	if j.AromaticRings != 0 {
		buf.WriteString(`"aromaticRings":`)
		fflib.AppendFloat(buf, float64(j.AromaticRings), 'g', -1, 64)
		buf.WriteByte(',')
	}
	if j.HeavyAtoms != 0 {
		buf.WriteString(`"heavyAtoms":`)
		fflib.AppendFloat(buf, float64(j.HeavyAtoms), 'g', -1, 64)
		buf.WriteByte(',')
	}
	if len(j.Formula) != 0 {
		buf.WriteString(`"formula":`)
		fflib.WriteJsonString(buf, string(j.Formula))
		buf.WriteByte(',')
	}
	if j.WeightMonoisotopic != 0 {
		buf.WriteString(`"weightMonoisotopic":`)
		fflib.AppendFloat(buf, float64(j.WeightMonoisotopic), 'g', -1, 64)
		buf.WriteByte(',')
	}
	if j.QedWeighted != 0 {
		buf.WriteString(`"qedWeighted":`)
		fflib.AppendFloat(buf, float64(j.QedWeighted), 'g', -1, 64)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChemblMoleculebase = iota
	ffjtChemblMoleculenosuchkey

	ffjtChemblMoleculeDesc

	ffjtChemblMoleculeHighestDevelopmentPhase

	ffjtChemblMoleculeAltNames

	ffjtChemblMoleculeAtcClassification

	ffjtChemblMoleculeIsBiotherapeutic

	ffjtChemblMoleculeHelmNotation

	ffjtChemblMoleculeHracClassification

	ffjtChemblMoleculeFracClassification

	ffjtChemblMoleculeIracClassification

	ffjtChemblMoleculeType

	ffjtChemblMoleculeBioComponentType

	ffjtChemblMoleculeBioComponentDescription

	ffjtChemblMoleculeBioComponentSquence

	ffjtChemblMoleculeBioComponentTaxo

	ffjtChemblMoleculeIndications

	ffjtChemblMoleculeParent

	ffjtChemblMoleculeChilds

	ffjtChemblMoleculeMechanism

	ffjtChemblMoleculeInchi

	ffjtChemblMoleculeName

	ffjtChemblMoleculeInchiKey

	ffjtChemblMoleculeSmiles

	ffjtChemblMoleculeAlogp

	ffjtChemblMoleculeWeightFreebase

	ffjtChemblMoleculeHba

	ffjtChemblMoleculeHbd

	ffjtChemblMoleculePsa

	ffjtChemblMoleculeRtb

	ffjtChemblMoleculeRo3Pass

	ffjtChemblMoleculeNumRo5Violations

	ffjtChemblMoleculeAcdMostApka

	ffjtChemblMoleculeAcdMostBpka

	ffjtChemblMoleculeAcdLogp

	ffjtChemblMoleculeAcdLogd

	ffjtChemblMoleculeMolecularSpecies

	ffjtChemblMoleculeWeight

	ffjtChemblMoleculeAromaticRings

	ffjtChemblMoleculeHeavyAtoms

	ffjtChemblMoleculeFormula

	ffjtChemblMoleculeWeightMonoisotopic

	ffjtChemblMoleculeQedWeighted
)

var ffjKeyChemblMoleculeDesc = []byte("desc")

var ffjKeyChemblMoleculeHighestDevelopmentPhase = []byte("highestDevelopmentPhase")

var ffjKeyChemblMoleculeAltNames = []byte("altNames")

var ffjKeyChemblMoleculeAtcClassification = []byte("atcClassification")

var ffjKeyChemblMoleculeIsBiotherapeutic = []byte("isBiotherapeutic")

var ffjKeyChemblMoleculeHelmNotation = []byte("helmNotation")

var ffjKeyChemblMoleculeHracClassification = []byte("hracClassification")

var ffjKeyChemblMoleculeFracClassification = []byte("fracClassification")

var ffjKeyChemblMoleculeIracClassification = []byte("iracClassification")

var ffjKeyChemblMoleculeType = []byte("type")

var ffjKeyChemblMoleculeBioComponentType = []byte("bioComponentType")

var ffjKeyChemblMoleculeBioComponentDescription = []byte("bioComponentDescription")

var ffjKeyChemblMoleculeBioComponentSquence = []byte("bioComponentSquence")

var ffjKeyChemblMoleculeBioComponentTaxo = []byte("bioComponentTaxo")

var ffjKeyChemblMoleculeIndications = []byte("indications")

var ffjKeyChemblMoleculeParent = []byte("parent")

var ffjKeyChemblMoleculeChilds = []byte("childs")

var ffjKeyChemblMoleculeMechanism = []byte("mechanism")

var ffjKeyChemblMoleculeInchi = []byte("inchi")

var ffjKeyChemblMoleculeName = []byte("name")

var ffjKeyChemblMoleculeInchiKey = []byte("inchiKey")

var ffjKeyChemblMoleculeSmiles = []byte("smiles")

var ffjKeyChemblMoleculeAlogp = []byte("alogp")

var ffjKeyChemblMoleculeWeightFreebase = []byte("weightFreebase")

var ffjKeyChemblMoleculeHba = []byte("hba")

var ffjKeyChemblMoleculeHbd = []byte("hbd")

var ffjKeyChemblMoleculePsa = []byte("psa")

var ffjKeyChemblMoleculeRtb = []byte("rtb")

var ffjKeyChemblMoleculeRo3Pass = []byte("ro3Pass")

var ffjKeyChemblMoleculeNumRo5Violations = []byte("numRo5Violations")

var ffjKeyChemblMoleculeAcdMostApka = []byte("acdMostApka")

var ffjKeyChemblMoleculeAcdMostBpka = []byte("acdMostBpka")

var ffjKeyChemblMoleculeAcdLogp = []byte("acdLogp")

var ffjKeyChemblMoleculeAcdLogd = []byte("acdLogd")

var ffjKeyChemblMoleculeMolecularSpecies = []byte("molecularSpecies")

var ffjKeyChemblMoleculeWeight = []byte("weight")

var ffjKeyChemblMoleculeAromaticRings = []byte("aromaticRings")

var ffjKeyChemblMoleculeHeavyAtoms = []byte("heavyAtoms")

var ffjKeyChemblMoleculeFormula = []byte("formula")

var ffjKeyChemblMoleculeWeightMonoisotopic = []byte("weightMonoisotopic")

var ffjKeyChemblMoleculeQedWeighted = []byte("qedWeighted")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChemblMolecule) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChemblMolecule) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChemblMoleculebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChemblMoleculenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyChemblMoleculeAltNames, kn) {
						currentKey = ffjtChemblMoleculeAltNames
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblMoleculeAtcClassification, kn) {
						currentKey = ffjtChemblMoleculeAtcClassification
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblMoleculeAlogp, kn) {
						currentKey = ffjtChemblMoleculeAlogp
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblMoleculeAcdMostApka, kn) {
						currentKey = ffjtChemblMoleculeAcdMostApka
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblMoleculeAcdMostBpka, kn) {
						currentKey = ffjtChemblMoleculeAcdMostBpka
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblMoleculeAcdLogp, kn) {
						currentKey = ffjtChemblMoleculeAcdLogp
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblMoleculeAcdLogd, kn) {
						currentKey = ffjtChemblMoleculeAcdLogd
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblMoleculeAromaticRings, kn) {
						currentKey = ffjtChemblMoleculeAromaticRings
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'b':

					if bytes.Equal(ffjKeyChemblMoleculeBioComponentType, kn) {
						currentKey = ffjtChemblMoleculeBioComponentType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblMoleculeBioComponentDescription, kn) {
						currentKey = ffjtChemblMoleculeBioComponentDescription
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblMoleculeBioComponentSquence, kn) {
						currentKey = ffjtChemblMoleculeBioComponentSquence
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblMoleculeBioComponentTaxo, kn) {
						currentKey = ffjtChemblMoleculeBioComponentTaxo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyChemblMoleculeChilds, kn) {
						currentKey = ffjtChemblMoleculeChilds
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyChemblMoleculeDesc, kn) {
						currentKey = ffjtChemblMoleculeDesc
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyChemblMoleculeFracClassification, kn) {
						currentKey = ffjtChemblMoleculeFracClassification
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblMoleculeFormula, kn) {
						currentKey = ffjtChemblMoleculeFormula
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyChemblMoleculeHighestDevelopmentPhase, kn) {
						currentKey = ffjtChemblMoleculeHighestDevelopmentPhase
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblMoleculeHelmNotation, kn) {
						currentKey = ffjtChemblMoleculeHelmNotation
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblMoleculeHracClassification, kn) {
						currentKey = ffjtChemblMoleculeHracClassification
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblMoleculeHba, kn) {
						currentKey = ffjtChemblMoleculeHba
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblMoleculeHbd, kn) {
						currentKey = ffjtChemblMoleculeHbd
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblMoleculeHeavyAtoms, kn) {
						currentKey = ffjtChemblMoleculeHeavyAtoms
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyChemblMoleculeIsBiotherapeutic, kn) {
						currentKey = ffjtChemblMoleculeIsBiotherapeutic
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblMoleculeIracClassification, kn) {
						currentKey = ffjtChemblMoleculeIracClassification
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblMoleculeIndications, kn) {
						currentKey = ffjtChemblMoleculeIndications
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblMoleculeInchi, kn) {
						currentKey = ffjtChemblMoleculeInchi
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblMoleculeInchiKey, kn) {
						currentKey = ffjtChemblMoleculeInchiKey
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyChemblMoleculeMechanism, kn) {
						currentKey = ffjtChemblMoleculeMechanism
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblMoleculeMolecularSpecies, kn) {
						currentKey = ffjtChemblMoleculeMolecularSpecies
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyChemblMoleculeName, kn) {
						currentKey = ffjtChemblMoleculeName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblMoleculeNumRo5Violations, kn) {
						currentKey = ffjtChemblMoleculeNumRo5Violations
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyChemblMoleculeParent, kn) {
						currentKey = ffjtChemblMoleculeParent
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblMoleculePsa, kn) {
						currentKey = ffjtChemblMoleculePsa
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'q':

					if bytes.Equal(ffjKeyChemblMoleculeQedWeighted, kn) {
						currentKey = ffjtChemblMoleculeQedWeighted
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyChemblMoleculeRtb, kn) {
						currentKey = ffjtChemblMoleculeRtb
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblMoleculeRo3Pass, kn) {
						currentKey = ffjtChemblMoleculeRo3Pass
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyChemblMoleculeSmiles, kn) {
						currentKey = ffjtChemblMoleculeSmiles
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyChemblMoleculeType, kn) {
						currentKey = ffjtChemblMoleculeType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyChemblMoleculeWeightFreebase, kn) {
						currentKey = ffjtChemblMoleculeWeightFreebase
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblMoleculeWeight, kn) {
						currentKey = ffjtChemblMoleculeWeight
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblMoleculeWeightMonoisotopic, kn) {
						currentKey = ffjtChemblMoleculeWeightMonoisotopic
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblMoleculeQedWeighted, kn) {
					currentKey = ffjtChemblMoleculeQedWeighted
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblMoleculeWeightMonoisotopic, kn) {
					currentKey = ffjtChemblMoleculeWeightMonoisotopic
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblMoleculeFormula, kn) {
					currentKey = ffjtChemblMoleculeFormula
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblMoleculeHeavyAtoms, kn) {
					currentKey = ffjtChemblMoleculeHeavyAtoms
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblMoleculeAromaticRings, kn) {
					currentKey = ffjtChemblMoleculeAromaticRings
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblMoleculeWeight, kn) {
					currentKey = ffjtChemblMoleculeWeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblMoleculeMolecularSpecies, kn) {
					currentKey = ffjtChemblMoleculeMolecularSpecies
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblMoleculeAcdLogd, kn) {
					currentKey = ffjtChemblMoleculeAcdLogd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblMoleculeAcdLogp, kn) {
					currentKey = ffjtChemblMoleculeAcdLogp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblMoleculeAcdMostBpka, kn) {
					currentKey = ffjtChemblMoleculeAcdMostBpka
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblMoleculeAcdMostApka, kn) {
					currentKey = ffjtChemblMoleculeAcdMostApka
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblMoleculeNumRo5Violations, kn) {
					currentKey = ffjtChemblMoleculeNumRo5Violations
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblMoleculeRo3Pass, kn) {
					currentKey = ffjtChemblMoleculeRo3Pass
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblMoleculeRtb, kn) {
					currentKey = ffjtChemblMoleculeRtb
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblMoleculePsa, kn) {
					currentKey = ffjtChemblMoleculePsa
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblMoleculeHbd, kn) {
					currentKey = ffjtChemblMoleculeHbd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblMoleculeHba, kn) {
					currentKey = ffjtChemblMoleculeHba
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblMoleculeWeightFreebase, kn) {
					currentKey = ffjtChemblMoleculeWeightFreebase
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblMoleculeAlogp, kn) {
					currentKey = ffjtChemblMoleculeAlogp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblMoleculeSmiles, kn) {
					currentKey = ffjtChemblMoleculeSmiles
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblMoleculeInchiKey, kn) {
					currentKey = ffjtChemblMoleculeInchiKey
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblMoleculeName, kn) {
					currentKey = ffjtChemblMoleculeName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblMoleculeInchi, kn) {
					currentKey = ffjtChemblMoleculeInchi
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblMoleculeMechanism, kn) {
					currentKey = ffjtChemblMoleculeMechanism
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblMoleculeChilds, kn) {
					currentKey = ffjtChemblMoleculeChilds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblMoleculeParent, kn) {
					currentKey = ffjtChemblMoleculeParent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblMoleculeIndications, kn) {
					currentKey = ffjtChemblMoleculeIndications
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblMoleculeBioComponentTaxo, kn) {
					currentKey = ffjtChemblMoleculeBioComponentTaxo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblMoleculeBioComponentSquence, kn) {
					currentKey = ffjtChemblMoleculeBioComponentSquence
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblMoleculeBioComponentDescription, kn) {
					currentKey = ffjtChemblMoleculeBioComponentDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblMoleculeBioComponentType, kn) {
					currentKey = ffjtChemblMoleculeBioComponentType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblMoleculeType, kn) {
					currentKey = ffjtChemblMoleculeType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblMoleculeIracClassification, kn) {
					currentKey = ffjtChemblMoleculeIracClassification
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblMoleculeFracClassification, kn) {
					currentKey = ffjtChemblMoleculeFracClassification
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblMoleculeHracClassification, kn) {
					currentKey = ffjtChemblMoleculeHracClassification
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblMoleculeHelmNotation, kn) {
					currentKey = ffjtChemblMoleculeHelmNotation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblMoleculeIsBiotherapeutic, kn) {
					currentKey = ffjtChemblMoleculeIsBiotherapeutic
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblMoleculeAtcClassification, kn) {
					currentKey = ffjtChemblMoleculeAtcClassification
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblMoleculeAltNames, kn) {
					currentKey = ffjtChemblMoleculeAltNames
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblMoleculeHighestDevelopmentPhase, kn) {
					currentKey = ffjtChemblMoleculeHighestDevelopmentPhase
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblMoleculeDesc, kn) {
					currentKey = ffjtChemblMoleculeDesc
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChemblMoleculenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChemblMoleculeDesc:
					goto handle_Desc

				case ffjtChemblMoleculeHighestDevelopmentPhase:
					goto handle_HighestDevelopmentPhase

				case ffjtChemblMoleculeAltNames:
					goto handle_AltNames

				case ffjtChemblMoleculeAtcClassification:
					goto handle_AtcClassification

				case ffjtChemblMoleculeIsBiotherapeutic:
					goto handle_IsBiotherapeutic

				case ffjtChemblMoleculeHelmNotation:
					goto handle_HelmNotation

				case ffjtChemblMoleculeHracClassification:
					goto handle_HracClassification

				case ffjtChemblMoleculeFracClassification:
					goto handle_FracClassification

				case ffjtChemblMoleculeIracClassification:
					goto handle_IracClassification

				case ffjtChemblMoleculeType:
					goto handle_Type

				case ffjtChemblMoleculeBioComponentType:
					goto handle_BioComponentType

				case ffjtChemblMoleculeBioComponentDescription:
					goto handle_BioComponentDescription

				case ffjtChemblMoleculeBioComponentSquence:
					goto handle_BioComponentSquence

				case ffjtChemblMoleculeBioComponentTaxo:
					goto handle_BioComponentTaxo

				case ffjtChemblMoleculeIndications:
					goto handle_Indications

				case ffjtChemblMoleculeParent:
					goto handle_Parent

				case ffjtChemblMoleculeChilds:
					goto handle_Childs

				case ffjtChemblMoleculeMechanism:
					goto handle_Mechanism

				case ffjtChemblMoleculeInchi:
					goto handle_Inchi

				case ffjtChemblMoleculeName:
					goto handle_Name

				case ffjtChemblMoleculeInchiKey:
					goto handle_InchiKey

				case ffjtChemblMoleculeSmiles:
					goto handle_Smiles

				case ffjtChemblMoleculeAlogp:
					goto handle_Alogp

				case ffjtChemblMoleculeWeightFreebase:
					goto handle_WeightFreebase

				case ffjtChemblMoleculeHba:
					goto handle_Hba

				case ffjtChemblMoleculeHbd:
					goto handle_Hbd

				case ffjtChemblMoleculePsa:
					goto handle_Psa

				case ffjtChemblMoleculeRtb:
					goto handle_Rtb

				case ffjtChemblMoleculeRo3Pass:
					goto handle_Ro3Pass

				case ffjtChemblMoleculeNumRo5Violations:
					goto handle_NumRo5Violations

				case ffjtChemblMoleculeAcdMostApka:
					goto handle_AcdMostApka

				case ffjtChemblMoleculeAcdMostBpka:
					goto handle_AcdMostBpka

				case ffjtChemblMoleculeAcdLogp:
					goto handle_AcdLogp

				case ffjtChemblMoleculeAcdLogd:
					goto handle_AcdLogd

				case ffjtChemblMoleculeMolecularSpecies:
					goto handle_MolecularSpecies

				case ffjtChemblMoleculeWeight:
					goto handle_Weight

				case ffjtChemblMoleculeAromaticRings:
					goto handle_AromaticRings

				case ffjtChemblMoleculeHeavyAtoms:
					goto handle_HeavyAtoms

				case ffjtChemblMoleculeFormula:
					goto handle_Formula

				case ffjtChemblMoleculeWeightMonoisotopic:
					goto handle_WeightMonoisotopic

				case ffjtChemblMoleculeQedWeighted:
					goto handle_QedWeighted

				case ffjtChemblMoleculenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Desc:

	/* handler: j.Desc type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Desc = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HighestDevelopmentPhase:

	/* handler: j.HighestDevelopmentPhase type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.HighestDevelopmentPhase = int32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AltNames:

	/* handler: j.AltNames type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.AltNames = nil
		} else {

			j.AltNames = []string{}

			wantVal := true

			for {

				var tmpJAltNames string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJAltNames type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJAltNames = string(string(outBuf))

					}
				}

				j.AltNames = append(j.AltNames, tmpJAltNames)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AtcClassification:

	/* handler: j.AtcClassification type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.AtcClassification = nil
		} else {

			j.AtcClassification = []string{}

			wantVal := true

			for {

				var tmpJAtcClassification string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJAtcClassification type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJAtcClassification = string(string(outBuf))

					}
				}

				j.AtcClassification = append(j.AtcClassification, tmpJAtcClassification)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsBiotherapeutic:

	/* handler: j.IsBiotherapeutic type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.IsBiotherapeutic = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HelmNotation:

	/* handler: j.HelmNotation type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.HelmNotation = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HracClassification:

	/* handler: j.HracClassification type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.HracClassification = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FracClassification:

	/* handler: j.FracClassification type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FracClassification = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IracClassification:

	/* handler: j.IracClassification type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.IracClassification = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BioComponentType:

	/* handler: j.BioComponentType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.BioComponentType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BioComponentDescription:

	/* handler: j.BioComponentDescription type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.BioComponentDescription = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BioComponentSquence:

	/* handler: j.BioComponentSquence type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.BioComponentSquence = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BioComponentTaxo:

	/* handler: j.BioComponentTaxo type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.BioComponentTaxo = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Indications:

	/* handler: j.Indications type=[]*pbuf.ChemblIndication kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Indications = nil
		} else {

			j.Indications = []*ChemblIndication{}

			wantVal := true

			for {

				var tmpJIndications *ChemblIndication

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJIndications type=*pbuf.ChemblIndication kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						tmpJIndications = nil

					} else {

						if tmpJIndications == nil {
							tmpJIndications = new(ChemblIndication)
						}

						err = tmpJIndications.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Indications = append(j.Indications, tmpJIndications)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Parent:

	/* handler: j.Parent type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Parent = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Childs:

	/* handler: j.Childs type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Childs = nil
		} else {

			j.Childs = []string{}

			wantVal := true

			for {

				var tmpJChilds string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJChilds type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJChilds = string(string(outBuf))

					}
				}

				j.Childs = append(j.Childs, tmpJChilds)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mechanism:

	/* handler: j.Mechanism type=pbuf.ChemblMechanism kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Mechanism = nil

		} else {

			if j.Mechanism == nil {
				j.Mechanism = new(ChemblMechanism)
			}

			err = j.Mechanism.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Inchi:

	/* handler: j.Inchi type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Inchi = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InchiKey:

	/* handler: j.InchiKey type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.InchiKey = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Smiles:

	/* handler: j.Smiles type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Smiles = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Alogp:

	/* handler: j.Alogp type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Alogp = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WeightFreebase:

	/* handler: j.WeightFreebase type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.WeightFreebase = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Hba:

	/* handler: j.Hba type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Hba = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Hbd:

	/* handler: j.Hbd type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Hbd = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Psa:

	/* handler: j.Psa type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Psa = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Rtb:

	/* handler: j.Rtb type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Rtb = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ro3Pass:

	/* handler: j.Ro3Pass type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Ro3Pass = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NumRo5Violations:

	/* handler: j.NumRo5Violations type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.NumRo5Violations = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AcdMostApka:

	/* handler: j.AcdMostApka type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.AcdMostApka = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AcdMostBpka:

	/* handler: j.AcdMostBpka type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.AcdMostBpka = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AcdLogp:

	/* handler: j.AcdLogp type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.AcdLogp = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AcdLogd:

	/* handler: j.AcdLogd type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.AcdLogd = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MolecularSpecies:

	/* handler: j.MolecularSpecies type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MolecularSpecies = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Weight:

	/* handler: j.Weight type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Weight = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AromaticRings:

	/* handler: j.AromaticRings type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.AromaticRings = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HeavyAtoms:

	/* handler: j.HeavyAtoms type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.HeavyAtoms = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Formula:

	/* handler: j.Formula type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Formula = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WeightMonoisotopic:

	/* handler: j.WeightMonoisotopic type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.WeightMonoisotopic = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_QedWeighted:

	/* handler: j.QedWeighted type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.QedWeighted = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChemblProteinTargetClassification) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChemblProteinTargetClassification) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.ClassName) != 0 {
		buf.WriteString(`"className":`)
		fflib.WriteJsonString(buf, string(j.ClassName))
		buf.WriteByte(',')
	}
	if len(j.ClassLevel) != 0 {
		buf.WriteString(`"classLevel":`)
		fflib.WriteJsonString(buf, string(j.ClassLevel))
		buf.WriteByte(',')
	}
	if len(j.ClassPath) != 0 {
		buf.WriteString(`"classPath":`)
		fflib.WriteJsonString(buf, string(j.ClassPath))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChemblProteinTargetClassificationbase = iota
	ffjtChemblProteinTargetClassificationnosuchkey

	ffjtChemblProteinTargetClassificationClassName

	ffjtChemblProteinTargetClassificationClassLevel

	ffjtChemblProteinTargetClassificationClassPath
)

var ffjKeyChemblProteinTargetClassificationClassName = []byte("className")

var ffjKeyChemblProteinTargetClassificationClassLevel = []byte("classLevel")

var ffjKeyChemblProteinTargetClassificationClassPath = []byte("classPath")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChemblProteinTargetClassification) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChemblProteinTargetClassification) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChemblProteinTargetClassificationbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChemblProteinTargetClassificationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyChemblProteinTargetClassificationClassName, kn) {
						currentKey = ffjtChemblProteinTargetClassificationClassName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblProteinTargetClassificationClassLevel, kn) {
						currentKey = ffjtChemblProteinTargetClassificationClassLevel
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblProteinTargetClassificationClassPath, kn) {
						currentKey = ffjtChemblProteinTargetClassificationClassPath
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyChemblProteinTargetClassificationClassPath, kn) {
					currentKey = ffjtChemblProteinTargetClassificationClassPath
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblProteinTargetClassificationClassLevel, kn) {
					currentKey = ffjtChemblProteinTargetClassificationClassLevel
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblProteinTargetClassificationClassName, kn) {
					currentKey = ffjtChemblProteinTargetClassificationClassName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChemblProteinTargetClassificationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChemblProteinTargetClassificationClassName:
					goto handle_ClassName

				case ffjtChemblProteinTargetClassificationClassLevel:
					goto handle_ClassLevel

				case ffjtChemblProteinTargetClassificationClassPath:
					goto handle_ClassPath

				case ffjtChemblProteinTargetClassificationnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ClassName:

	/* handler: j.ClassName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ClassName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ClassLevel:

	/* handler: j.ClassLevel type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ClassLevel = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ClassPath:

	/* handler: j.ClassPath type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ClassPath = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChemblTarget) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChemblTarget) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.Title) != 0 {
		buf.WriteString(`"title":`)
		fflib.WriteJsonString(buf, string(j.Title))
		buf.WriteByte(',')
	}
	if len(j.IsSpeciesGroup) != 0 {
		buf.WriteString(`"isSpeciesGroup":`)
		fflib.WriteJsonString(buf, string(j.IsSpeciesGroup))
		buf.WriteByte(',')
	}
	if len(j.Type) != 0 {
		buf.WriteString(`"type":`)
		fflib.WriteJsonString(buf, string(j.Type))
		buf.WriteByte(',')
	}
	if len(j.Subsetofs) != 0 {
		buf.WriteString(`"subsetofs":`)
		if j.Subsetofs != nil {
			buf.WriteString(`[`)
			for i, v := range j.Subsetofs {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Equivalents) != 0 {
		buf.WriteString(`"equivalents":`)
		if j.Equivalents != nil {
			buf.WriteString(`[`)
			for i, v := range j.Equivalents {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Subsets) != 0 {
		buf.WriteString(`"subsets":`)
		if j.Subsets != nil {
			buf.WriteString(`[`)
			for i, v := range j.Subsets {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Overlaps) != 0 {
		buf.WriteString(`"overlaps":`)
		if j.Overlaps != nil {
			buf.WriteString(`[`)
			for i, v := range j.Overlaps {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if j.BindingSite != nil {
		if true {
			buf.WriteString(`"bindingSite":`)

			{

				err = j.BindingSite.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.Ptclassifications) != 0 {
		buf.WriteString(`"ptclassifications":`)
		if j.Ptclassifications != nil {
			buf.WriteString(`[`)
			for i, v := range j.Ptclassifications {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
					} else {

						err = v.MarshalJSONBuf(buf)
						if err != nil {
							return err
						}

					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Components) != 0 {
		buf.WriteString(`"components":`)
		if j.Components != nil {
			buf.WriteString(`[`)
			for i, v := range j.Components {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
					} else {

						err = v.MarshalJSONBuf(buf)
						if err != nil {
							return err
						}

					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if j.Mechanism != nil {
		if true {
			buf.WriteString(`"mechanism":`)

			{

				err = j.Mechanism.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.Tax) != 0 {
		buf.WriteString(`"tax":`)
		fflib.WriteJsonString(buf, string(j.Tax))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChemblTargetbase = iota
	ffjtChemblTargetnosuchkey

	ffjtChemblTargetTitle

	ffjtChemblTargetIsSpeciesGroup

	ffjtChemblTargetType

	ffjtChemblTargetSubsetofs

	ffjtChemblTargetEquivalents

	ffjtChemblTargetSubsets

	ffjtChemblTargetOverlaps

	ffjtChemblTargetBindingSite

	ffjtChemblTargetPtclassifications

	ffjtChemblTargetComponents

	ffjtChemblTargetMechanism

	ffjtChemblTargetTax
)

var ffjKeyChemblTargetTitle = []byte("title")

var ffjKeyChemblTargetIsSpeciesGroup = []byte("isSpeciesGroup")

var ffjKeyChemblTargetType = []byte("type")

var ffjKeyChemblTargetSubsetofs = []byte("subsetofs")

var ffjKeyChemblTargetEquivalents = []byte("equivalents")

var ffjKeyChemblTargetSubsets = []byte("subsets")

var ffjKeyChemblTargetOverlaps = []byte("overlaps")

var ffjKeyChemblTargetBindingSite = []byte("bindingSite")

var ffjKeyChemblTargetPtclassifications = []byte("ptclassifications")

var ffjKeyChemblTargetComponents = []byte("components")

var ffjKeyChemblTargetMechanism = []byte("mechanism")

var ffjKeyChemblTargetTax = []byte("tax")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChemblTarget) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChemblTarget) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChemblTargetbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChemblTargetnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffjKeyChemblTargetBindingSite, kn) {
						currentKey = ffjtChemblTargetBindingSite
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyChemblTargetComponents, kn) {
						currentKey = ffjtChemblTargetComponents
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyChemblTargetEquivalents, kn) {
						currentKey = ffjtChemblTargetEquivalents
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyChemblTargetIsSpeciesGroup, kn) {
						currentKey = ffjtChemblTargetIsSpeciesGroup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyChemblTargetMechanism, kn) {
						currentKey = ffjtChemblTargetMechanism
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyChemblTargetOverlaps, kn) {
						currentKey = ffjtChemblTargetOverlaps
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyChemblTargetPtclassifications, kn) {
						currentKey = ffjtChemblTargetPtclassifications
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyChemblTargetSubsetofs, kn) {
						currentKey = ffjtChemblTargetSubsetofs
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblTargetSubsets, kn) {
						currentKey = ffjtChemblTargetSubsets
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyChemblTargetTitle, kn) {
						currentKey = ffjtChemblTargetTitle
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblTargetType, kn) {
						currentKey = ffjtChemblTargetType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblTargetTax, kn) {
						currentKey = ffjtChemblTargetTax
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblTargetTax, kn) {
					currentKey = ffjtChemblTargetTax
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblTargetMechanism, kn) {
					currentKey = ffjtChemblTargetMechanism
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblTargetComponents, kn) {
					currentKey = ffjtChemblTargetComponents
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblTargetPtclassifications, kn) {
					currentKey = ffjtChemblTargetPtclassifications
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblTargetBindingSite, kn) {
					currentKey = ffjtChemblTargetBindingSite
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblTargetOverlaps, kn) {
					currentKey = ffjtChemblTargetOverlaps
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblTargetSubsets, kn) {
					currentKey = ffjtChemblTargetSubsets
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblTargetEquivalents, kn) {
					currentKey = ffjtChemblTargetEquivalents
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblTargetSubsetofs, kn) {
					currentKey = ffjtChemblTargetSubsetofs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblTargetType, kn) {
					currentKey = ffjtChemblTargetType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblTargetIsSpeciesGroup, kn) {
					currentKey = ffjtChemblTargetIsSpeciesGroup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblTargetTitle, kn) {
					currentKey = ffjtChemblTargetTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChemblTargetnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChemblTargetTitle:
					goto handle_Title

				case ffjtChemblTargetIsSpeciesGroup:
					goto handle_IsSpeciesGroup

				case ffjtChemblTargetType:
					goto handle_Type

				case ffjtChemblTargetSubsetofs:
					goto handle_Subsetofs

				case ffjtChemblTargetEquivalents:
					goto handle_Equivalents

				case ffjtChemblTargetSubsets:
					goto handle_Subsets

				case ffjtChemblTargetOverlaps:
					goto handle_Overlaps

				case ffjtChemblTargetBindingSite:
					goto handle_BindingSite

				case ffjtChemblTargetPtclassifications:
					goto handle_Ptclassifications

				case ffjtChemblTargetComponents:
					goto handle_Components

				case ffjtChemblTargetMechanism:
					goto handle_Mechanism

				case ffjtChemblTargetTax:
					goto handle_Tax

				case ffjtChemblTargetnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsSpeciesGroup:

	/* handler: j.IsSpeciesGroup type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.IsSpeciesGroup = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Subsetofs:

	/* handler: j.Subsetofs type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Subsetofs = nil
		} else {

			j.Subsetofs = []string{}

			wantVal := true

			for {

				var tmpJSubsetofs string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJSubsetofs type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJSubsetofs = string(string(outBuf))

					}
				}

				j.Subsetofs = append(j.Subsetofs, tmpJSubsetofs)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Equivalents:

	/* handler: j.Equivalents type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Equivalents = nil
		} else {

			j.Equivalents = []string{}

			wantVal := true

			for {

				var tmpJEquivalents string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJEquivalents type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJEquivalents = string(string(outBuf))

					}
				}

				j.Equivalents = append(j.Equivalents, tmpJEquivalents)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Subsets:

	/* handler: j.Subsets type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Subsets = nil
		} else {

			j.Subsets = []string{}

			wantVal := true

			for {

				var tmpJSubsets string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJSubsets type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJSubsets = string(string(outBuf))

					}
				}

				j.Subsets = append(j.Subsets, tmpJSubsets)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Overlaps:

	/* handler: j.Overlaps type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Overlaps = nil
		} else {

			j.Overlaps = []string{}

			wantVal := true

			for {

				var tmpJOverlaps string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJOverlaps type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJOverlaps = string(string(outBuf))

					}
				}

				j.Overlaps = append(j.Overlaps, tmpJOverlaps)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BindingSite:

	/* handler: j.BindingSite type=pbuf.ChemblBindingSite kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.BindingSite = nil

		} else {

			if j.BindingSite == nil {
				j.BindingSite = new(ChemblBindingSite)
			}

			err = j.BindingSite.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ptclassifications:

	/* handler: j.Ptclassifications type=[]*pbuf.ChemblProteinTargetClassification kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Ptclassifications = nil
		} else {

			j.Ptclassifications = []*ChemblProteinTargetClassification{}

			wantVal := true

			for {

				var tmpJPtclassifications *ChemblProteinTargetClassification

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJPtclassifications type=*pbuf.ChemblProteinTargetClassification kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						tmpJPtclassifications = nil

					} else {

						if tmpJPtclassifications == nil {
							tmpJPtclassifications = new(ChemblProteinTargetClassification)
						}

						err = tmpJPtclassifications.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Ptclassifications = append(j.Ptclassifications, tmpJPtclassifications)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Components:

	/* handler: j.Components type=[]*pbuf.ChemblTargetComponentInfo kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Components = nil
		} else {

			j.Components = []*ChemblTargetComponentInfo{}

			wantVal := true

			for {

				var tmpJComponents *ChemblTargetComponentInfo

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJComponents type=*pbuf.ChemblTargetComponentInfo kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						tmpJComponents = nil

					} else {

						if tmpJComponents == nil {
							tmpJComponents = new(ChemblTargetComponentInfo)
						}

						err = tmpJComponents.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Components = append(j.Components, tmpJComponents)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mechanism:

	/* handler: j.Mechanism type=pbuf.ChemblMechanism kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Mechanism = nil

		} else {

			if j.Mechanism == nil {
				j.Mechanism = new(ChemblMechanism)
			}

			err = j.Mechanism.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tax:

	/* handler: j.Tax type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Tax = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChemblTargetComponent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChemblTargetComponent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.Desc) != 0 {
		buf.WriteString(`"desc":`)
		fflib.WriteJsonString(buf, string(j.Desc))
		buf.WriteByte(',')
	}
	if len(j.AltLabel) != 0 {
		buf.WriteString(`"altLabel":`)
		fflib.WriteJsonString(buf, string(j.AltLabel))
		buf.WriteByte(',')
	}
	if len(j.Type) != 0 {
		buf.WriteString(`"type":`)
		fflib.WriteJsonString(buf, string(j.Type))
		buf.WriteByte(',')
	}
	if len(j.Ptclassifications) != 0 {
		buf.WriteString(`"ptclassifications":`)
		if j.Ptclassifications != nil {
			buf.WriteString(`[`)
			for i, v := range j.Ptclassifications {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
					} else {

						err = v.MarshalJSONBuf(buf)
						if err != nil {
							return err
						}

					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Acc) != 0 {
		buf.WriteString(`"acc":`)
		fflib.WriteJsonString(buf, string(j.Acc))
		buf.WriteByte(',')
	}
	if len(j.Tax) != 0 {
		buf.WriteString(`"tax":`)
		fflib.WriteJsonString(buf, string(j.Tax))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChemblTargetComponentbase = iota
	ffjtChemblTargetComponentnosuchkey

	ffjtChemblTargetComponentDesc

	ffjtChemblTargetComponentAltLabel

	ffjtChemblTargetComponentType

	ffjtChemblTargetComponentPtclassifications

	ffjtChemblTargetComponentAcc

	ffjtChemblTargetComponentTax
)

var ffjKeyChemblTargetComponentDesc = []byte("desc")

var ffjKeyChemblTargetComponentAltLabel = []byte("altLabel")

var ffjKeyChemblTargetComponentType = []byte("type")

var ffjKeyChemblTargetComponentPtclassifications = []byte("ptclassifications")

var ffjKeyChemblTargetComponentAcc = []byte("acc")

var ffjKeyChemblTargetComponentTax = []byte("tax")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChemblTargetComponent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChemblTargetComponent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChemblTargetComponentbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChemblTargetComponentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyChemblTargetComponentAltLabel, kn) {
						currentKey = ffjtChemblTargetComponentAltLabel
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblTargetComponentAcc, kn) {
						currentKey = ffjtChemblTargetComponentAcc
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyChemblTargetComponentDesc, kn) {
						currentKey = ffjtChemblTargetComponentDesc
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyChemblTargetComponentPtclassifications, kn) {
						currentKey = ffjtChemblTargetComponentPtclassifications
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyChemblTargetComponentType, kn) {
						currentKey = ffjtChemblTargetComponentType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChemblTargetComponentTax, kn) {
						currentKey = ffjtChemblTargetComponentTax
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblTargetComponentTax, kn) {
					currentKey = ffjtChemblTargetComponentTax
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblTargetComponentAcc, kn) {
					currentKey = ffjtChemblTargetComponentAcc
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblTargetComponentPtclassifications, kn) {
					currentKey = ffjtChemblTargetComponentPtclassifications
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblTargetComponentType, kn) {
					currentKey = ffjtChemblTargetComponentType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblTargetComponentAltLabel, kn) {
					currentKey = ffjtChemblTargetComponentAltLabel
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChemblTargetComponentDesc, kn) {
					currentKey = ffjtChemblTargetComponentDesc
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChemblTargetComponentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChemblTargetComponentDesc:
					goto handle_Desc

				case ffjtChemblTargetComponentAltLabel:
					goto handle_AltLabel

				case ffjtChemblTargetComponentType:
					goto handle_Type

				case ffjtChemblTargetComponentPtclassifications:
					goto handle_Ptclassifications

				case ffjtChemblTargetComponentAcc:
					goto handle_Acc

				case ffjtChemblTargetComponentTax:
					goto handle_Tax

				case ffjtChemblTargetComponentnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Desc:

	/* handler: j.Desc type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Desc = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AltLabel:

	/* handler: j.AltLabel type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.AltLabel = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ptclassifications:

	/* handler: j.Ptclassifications type=[]*pbuf.ChemblProteinTargetClassification kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Ptclassifications = nil
		} else {

			j.Ptclassifications = []*ChemblProteinTargetClassification{}

			wantVal := true

			for {

				var tmpJPtclassifications *ChemblProteinTargetClassification

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJPtclassifications type=*pbuf.ChemblProteinTargetClassification kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						tmpJPtclassifications = nil

					} else {

						if tmpJPtclassifications == nil {
							tmpJPtclassifications = new(ChemblProteinTargetClassification)
						}

						err = tmpJPtclassifications.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Ptclassifications = append(j.Ptclassifications, tmpJPtclassifications)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Acc:

	/* handler: j.Acc type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Acc = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tax:

	/* handler: j.Tax type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Tax = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChemblTargetComponentInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChemblTargetComponentInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.Type) != 0 {
		buf.WriteString(`"type":`)
		fflib.WriteJsonString(buf, string(j.Type))
		buf.WriteByte(',')
	}
	if len(j.Acc) != 0 {
		buf.WriteString(`"acc":`)
		fflib.WriteJsonString(buf, string(j.Acc))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChemblTargetComponentInfobase = iota
	ffjtChemblTargetComponentInfonosuchkey

	ffjtChemblTargetComponentInfoType

	ffjtChemblTargetComponentInfoAcc
)

var ffjKeyChemblTargetComponentInfoType = []byte("type")

var ffjKeyChemblTargetComponentInfoAcc = []byte("acc")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChemblTargetComponentInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChemblTargetComponentInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChemblTargetComponentInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChemblTargetComponentInfonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyChemblTargetComponentInfoAcc, kn) {
						currentKey = ffjtChemblTargetComponentInfoAcc
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyChemblTargetComponentInfoType, kn) {
						currentKey = ffjtChemblTargetComponentInfoType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblTargetComponentInfoAcc, kn) {
					currentKey = ffjtChemblTargetComponentInfoAcc
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChemblTargetComponentInfoType, kn) {
					currentKey = ffjtChemblTargetComponentInfoType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChemblTargetComponentInfonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChemblTargetComponentInfoType:
					goto handle_Type

				case ffjtChemblTargetComponentInfoAcc:
					goto handle_Acc

				case ffjtChemblTargetComponentInfonosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Acc:

	/* handler: j.Acc type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Acc = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *DrugbankAttr) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *DrugbankAttr) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.Name) != 0 {
		buf.WriteString(`"name":`)
		fflib.WriteJsonString(buf, string(j.Name))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtDrugbankAttrbase = iota
	ffjtDrugbankAttrnosuchkey

	ffjtDrugbankAttrName
)

var ffjKeyDrugbankAttrName = []byte("name")

// UnmarshalJSON umarshall json - template of ffjson
func (j *DrugbankAttr) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *DrugbankAttr) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtDrugbankAttrbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtDrugbankAttrnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'n':

					if bytes.Equal(ffjKeyDrugbankAttrName, kn) {
						currentKey = ffjtDrugbankAttrName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyDrugbankAttrName, kn) {
					currentKey = ffjtDrugbankAttrName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtDrugbankAttrnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtDrugbankAttrName:
					goto handle_Name

				case ffjtDrugbankAttrnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *EnaAttr) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *EnaAttr) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.Type) != 0 {
		buf.WriteString(`"type":`)
		fflib.WriteJsonString(buf, string(j.Type))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtEnaAttrbase = iota
	ffjtEnaAttrnosuchkey

	ffjtEnaAttrType
)

var ffjKeyEnaAttrType = []byte("type")

// UnmarshalJSON umarshall json - template of ffjson
func (j *EnaAttr) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *EnaAttr) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtEnaAttrbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtEnaAttrnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 't':

					if bytes.Equal(ffjKeyEnaAttrType, kn) {
						currentKey = ffjtEnaAttrType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyEnaAttrType, kn) {
					currentKey = ffjtEnaAttrType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtEnaAttrnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtEnaAttrType:
					goto handle_Type

				case ffjtEnaAttrnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *EnsemblAttr) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *EnsemblAttr) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.Name) != 0 {
		buf.WriteString(`"name":`)
		fflib.WriteJsonString(buf, string(j.Name))
		buf.WriteByte(',')
	}
	if len(j.Description) != 0 {
		buf.WriteString(`"description":`)
		fflib.WriteJsonString(buf, string(j.Description))
		buf.WriteByte(',')
	}
	if j.Start != 0 {
		buf.WriteString(`"start":`)
		fflib.FormatBits2(buf, uint64(j.Start), 10, j.Start < 0)
		buf.WriteByte(',')
	}
	if j.End != 0 {
		buf.WriteString(`"end":`)
		fflib.FormatBits2(buf, uint64(j.End), 10, j.End < 0)
		buf.WriteByte(',')
	}
	if len(j.Biotype) != 0 {
		buf.WriteString(`"biotype":`)
		fflib.WriteJsonString(buf, string(j.Biotype))
		buf.WriteByte(',')
	}
	if len(j.Genome) != 0 {
		buf.WriteString(`"genome":`)
		fflib.WriteJsonString(buf, string(j.Genome))
		buf.WriteByte(',')
	}
	if len(j.Strand) != 0 {
		buf.WriteString(`"strand":`)
		fflib.WriteJsonString(buf, string(j.Strand))
		buf.WriteByte(',')
	}
	if len(j.SeqRegion) != 0 {
		buf.WriteString(`"seq_region":`)
		fflib.WriteJsonString(buf, string(j.SeqRegion))
		buf.WriteByte(',')
	}
	if j.Branch != 0 {
		buf.WriteString(`"branch":`)
		fflib.FormatBits2(buf, uint64(j.Branch), 10, j.Branch < 0)
		buf.WriteByte(',')
	}
	if j.Utr5Start != 0 {
		buf.WriteString(`"utr5Start":`)
		fflib.FormatBits2(buf, uint64(j.Utr5Start), 10, j.Utr5Start < 0)
		buf.WriteByte(',')
	}
	if j.Utr5End != 0 {
		buf.WriteString(`"utr5End":`)
		fflib.FormatBits2(buf, uint64(j.Utr5End), 10, j.Utr5End < 0)
		buf.WriteByte(',')
	}
	if j.Utr3Start != 0 {
		buf.WriteString(`"utr3Start":`)
		fflib.FormatBits2(buf, uint64(j.Utr3Start), 10, j.Utr3Start < 0)
		buf.WriteByte(',')
	}
	if j.Utr3End != 0 {
		buf.WriteString(`"utr3End":`)
		fflib.FormatBits2(buf, uint64(j.Utr3End), 10, j.Utr3End < 0)
		buf.WriteByte(',')
	}
	if j.Version != 0 {
		buf.WriteString(`"version":`)
		fflib.FormatBits2(buf, uint64(j.Version), 10, j.Version < 0)
		buf.WriteByte(',')
	}
	if len(j.Source) != 0 {
		buf.WriteString(`"source":`)
		fflib.WriteJsonString(buf, string(j.Source))
		buf.WriteByte(',')
	}
	if j.Frame != 0 {
		buf.WriteString(`"frame":`)
		fflib.FormatBits2(buf, uint64(j.Frame), 10, j.Frame < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtEnsemblAttrbase = iota
	ffjtEnsemblAttrnosuchkey

	ffjtEnsemblAttrName

	ffjtEnsemblAttrDescription

	ffjtEnsemblAttrStart

	ffjtEnsemblAttrEnd

	ffjtEnsemblAttrBiotype

	ffjtEnsemblAttrGenome

	ffjtEnsemblAttrStrand

	ffjtEnsemblAttrSeqRegion

	ffjtEnsemblAttrBranch

	ffjtEnsemblAttrUtr5Start

	ffjtEnsemblAttrUtr5End

	ffjtEnsemblAttrUtr3Start

	ffjtEnsemblAttrUtr3End

	ffjtEnsemblAttrVersion

	ffjtEnsemblAttrSource

	ffjtEnsemblAttrFrame
)

var ffjKeyEnsemblAttrName = []byte("name")

var ffjKeyEnsemblAttrDescription = []byte("description")

var ffjKeyEnsemblAttrStart = []byte("start")

var ffjKeyEnsemblAttrEnd = []byte("end")

var ffjKeyEnsemblAttrBiotype = []byte("biotype")

var ffjKeyEnsemblAttrGenome = []byte("genome")

var ffjKeyEnsemblAttrStrand = []byte("strand")

var ffjKeyEnsemblAttrSeqRegion = []byte("seq_region")

var ffjKeyEnsemblAttrBranch = []byte("branch")

var ffjKeyEnsemblAttrUtr5Start = []byte("utr5Start")

var ffjKeyEnsemblAttrUtr5End = []byte("utr5End")

var ffjKeyEnsemblAttrUtr3Start = []byte("utr3Start")

var ffjKeyEnsemblAttrUtr3End = []byte("utr3End")

var ffjKeyEnsemblAttrVersion = []byte("version")

var ffjKeyEnsemblAttrSource = []byte("source")

var ffjKeyEnsemblAttrFrame = []byte("frame")

// UnmarshalJSON umarshall json - template of ffjson
func (j *EnsemblAttr) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *EnsemblAttr) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtEnsemblAttrbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtEnsemblAttrnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffjKeyEnsemblAttrBiotype, kn) {
						currentKey = ffjtEnsemblAttrBiotype
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEnsemblAttrBranch, kn) {
						currentKey = ffjtEnsemblAttrBranch
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyEnsemblAttrDescription, kn) {
						currentKey = ffjtEnsemblAttrDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyEnsemblAttrEnd, kn) {
						currentKey = ffjtEnsemblAttrEnd
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyEnsemblAttrFrame, kn) {
						currentKey = ffjtEnsemblAttrFrame
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyEnsemblAttrGenome, kn) {
						currentKey = ffjtEnsemblAttrGenome
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyEnsemblAttrName, kn) {
						currentKey = ffjtEnsemblAttrName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyEnsemblAttrStart, kn) {
						currentKey = ffjtEnsemblAttrStart
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEnsemblAttrStrand, kn) {
						currentKey = ffjtEnsemblAttrStrand
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEnsemblAttrSeqRegion, kn) {
						currentKey = ffjtEnsemblAttrSeqRegion
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEnsemblAttrSource, kn) {
						currentKey = ffjtEnsemblAttrSource
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyEnsemblAttrUtr5Start, kn) {
						currentKey = ffjtEnsemblAttrUtr5Start
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEnsemblAttrUtr5End, kn) {
						currentKey = ffjtEnsemblAttrUtr5End
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEnsemblAttrUtr3Start, kn) {
						currentKey = ffjtEnsemblAttrUtr3Start
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEnsemblAttrUtr3End, kn) {
						currentKey = ffjtEnsemblAttrUtr3End
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyEnsemblAttrVersion, kn) {
						currentKey = ffjtEnsemblAttrVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyEnsemblAttrFrame, kn) {
					currentKey = ffjtEnsemblAttrFrame
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEnsemblAttrSource, kn) {
					currentKey = ffjtEnsemblAttrSource
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEnsemblAttrVersion, kn) {
					currentKey = ffjtEnsemblAttrVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyEnsemblAttrUtr3End, kn) {
					currentKey = ffjtEnsemblAttrUtr3End
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEnsemblAttrUtr3Start, kn) {
					currentKey = ffjtEnsemblAttrUtr3Start
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyEnsemblAttrUtr5End, kn) {
					currentKey = ffjtEnsemblAttrUtr5End
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEnsemblAttrUtr5Start, kn) {
					currentKey = ffjtEnsemblAttrUtr5Start
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEnsemblAttrBranch, kn) {
					currentKey = ffjtEnsemblAttrBranch
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEnsemblAttrSeqRegion, kn) {
					currentKey = ffjtEnsemblAttrSeqRegion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEnsemblAttrStrand, kn) {
					currentKey = ffjtEnsemblAttrStrand
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEnsemblAttrGenome, kn) {
					currentKey = ffjtEnsemblAttrGenome
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEnsemblAttrBiotype, kn) {
					currentKey = ffjtEnsemblAttrBiotype
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEnsemblAttrEnd, kn) {
					currentKey = ffjtEnsemblAttrEnd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEnsemblAttrStart, kn) {
					currentKey = ffjtEnsemblAttrStart
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEnsemblAttrDescription, kn) {
					currentKey = ffjtEnsemblAttrDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEnsemblAttrName, kn) {
					currentKey = ffjtEnsemblAttrName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtEnsemblAttrnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtEnsemblAttrName:
					goto handle_Name

				case ffjtEnsemblAttrDescription:
					goto handle_Description

				case ffjtEnsemblAttrStart:
					goto handle_Start

				case ffjtEnsemblAttrEnd:
					goto handle_End

				case ffjtEnsemblAttrBiotype:
					goto handle_Biotype

				case ffjtEnsemblAttrGenome:
					goto handle_Genome

				case ffjtEnsemblAttrStrand:
					goto handle_Strand

				case ffjtEnsemblAttrSeqRegion:
					goto handle_SeqRegion

				case ffjtEnsemblAttrBranch:
					goto handle_Branch

				case ffjtEnsemblAttrUtr5Start:
					goto handle_Utr5Start

				case ffjtEnsemblAttrUtr5End:
					goto handle_Utr5End

				case ffjtEnsemblAttrUtr3Start:
					goto handle_Utr3Start

				case ffjtEnsemblAttrUtr3End:
					goto handle_Utr3End

				case ffjtEnsemblAttrVersion:
					goto handle_Version

				case ffjtEnsemblAttrSource:
					goto handle_Source

				case ffjtEnsemblAttrFrame:
					goto handle_Frame

				case ffjtEnsemblAttrnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Start:

	/* handler: j.Start type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Start = int32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_End:

	/* handler: j.End type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.End = int32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Biotype:

	/* handler: j.Biotype type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Biotype = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Genome:

	/* handler: j.Genome type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Genome = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Strand:

	/* handler: j.Strand type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Strand = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SeqRegion:

	/* handler: j.SeqRegion type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.SeqRegion = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Branch:

	/* handler: j.Branch type=pbuf.Ensemblbranch kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for Ensemblbranch", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Branch = Ensemblbranch(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Utr5Start:

	/* handler: j.Utr5Start type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Utr5Start = int32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Utr5End:

	/* handler: j.Utr5End type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Utr5End = int32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Utr3Start:

	/* handler: j.Utr3Start type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Utr3Start = int32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Utr3End:

	/* handler: j.Utr3End type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Utr3End = int32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Version:

	/* handler: j.Version type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Version = int32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Source:

	/* handler: j.Source type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Source = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Frame:

	/* handler: j.Frame type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Frame = int32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *HgncAttr) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *HgncAttr) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.Names) != 0 {
		buf.WriteString(`"names":`)
		if j.Names != nil {
			buf.WriteString(`[`)
			for i, v := range j.Names {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Symbols) != 0 {
		buf.WriteString(`"symbols":`)
		if j.Symbols != nil {
			buf.WriteString(`[`)
			for i, v := range j.Symbols {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.LocusGroup) != 0 {
		buf.WriteString(`"locus_group":`)
		fflib.WriteJsonString(buf, string(j.LocusGroup))
		buf.WriteByte(',')
	}
	if len(j.Location) != 0 {
		buf.WriteString(`"location":`)
		fflib.WriteJsonString(buf, string(j.Location))
		buf.WriteByte(',')
	}
	if len(j.Aliases) != 0 {
		buf.WriteString(`"aliases":`)
		if j.Aliases != nil {
			buf.WriteString(`[`)
			for i, v := range j.Aliases {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.LocusType) != 0 {
		buf.WriteString(`"locus_type":`)
		fflib.WriteJsonString(buf, string(j.LocusType))
		buf.WriteByte(',')
	}
	if len(j.PrevNames) != 0 {
		buf.WriteString(`"prev_names":`)
		if j.PrevNames != nil {
			buf.WriteString(`[`)
			for i, v := range j.PrevNames {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.PrevSymbols) != 0 {
		buf.WriteString(`"prev_symbols":`)
		if j.PrevSymbols != nil {
			buf.WriteString(`[`)
			for i, v := range j.PrevSymbols {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Status) != 0 {
		buf.WriteString(`"status":`)
		fflib.WriteJsonString(buf, string(j.Status))
		buf.WriteByte(',')
	}
	if len(j.GeneGroups) != 0 {
		buf.WriteString(`"gene_groups":`)
		if j.GeneGroups != nil {
			buf.WriteString(`[`)
			for i, v := range j.GeneGroups {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtHgncAttrbase = iota
	ffjtHgncAttrnosuchkey

	ffjtHgncAttrNames

	ffjtHgncAttrSymbols

	ffjtHgncAttrLocusGroup

	ffjtHgncAttrLocation

	ffjtHgncAttrAliases

	ffjtHgncAttrLocusType

	ffjtHgncAttrPrevNames

	ffjtHgncAttrPrevSymbols

	ffjtHgncAttrStatus

	ffjtHgncAttrGeneGroups
)

var ffjKeyHgncAttrNames = []byte("names")

var ffjKeyHgncAttrSymbols = []byte("symbols")

var ffjKeyHgncAttrLocusGroup = []byte("locus_group")

var ffjKeyHgncAttrLocation = []byte("location")

var ffjKeyHgncAttrAliases = []byte("aliases")

var ffjKeyHgncAttrLocusType = []byte("locus_type")

var ffjKeyHgncAttrPrevNames = []byte("prev_names")

var ffjKeyHgncAttrPrevSymbols = []byte("prev_symbols")

var ffjKeyHgncAttrStatus = []byte("status")

var ffjKeyHgncAttrGeneGroups = []byte("gene_groups")

// UnmarshalJSON umarshall json - template of ffjson
func (j *HgncAttr) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *HgncAttr) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtHgncAttrbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtHgncAttrnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyHgncAttrAliases, kn) {
						currentKey = ffjtHgncAttrAliases
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyHgncAttrGeneGroups, kn) {
						currentKey = ffjtHgncAttrGeneGroups
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyHgncAttrLocusGroup, kn) {
						currentKey = ffjtHgncAttrLocusGroup
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyHgncAttrLocation, kn) {
						currentKey = ffjtHgncAttrLocation
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyHgncAttrLocusType, kn) {
						currentKey = ffjtHgncAttrLocusType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyHgncAttrNames, kn) {
						currentKey = ffjtHgncAttrNames
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyHgncAttrPrevNames, kn) {
						currentKey = ffjtHgncAttrPrevNames
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyHgncAttrPrevSymbols, kn) {
						currentKey = ffjtHgncAttrPrevSymbols
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyHgncAttrSymbols, kn) {
						currentKey = ffjtHgncAttrSymbols
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyHgncAttrStatus, kn) {
						currentKey = ffjtHgncAttrStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyHgncAttrGeneGroups, kn) {
					currentKey = ffjtHgncAttrGeneGroups
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHgncAttrStatus, kn) {
					currentKey = ffjtHgncAttrStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHgncAttrPrevSymbols, kn) {
					currentKey = ffjtHgncAttrPrevSymbols
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHgncAttrPrevNames, kn) {
					currentKey = ffjtHgncAttrPrevNames
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHgncAttrLocusType, kn) {
					currentKey = ffjtHgncAttrLocusType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHgncAttrAliases, kn) {
					currentKey = ffjtHgncAttrAliases
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyHgncAttrLocation, kn) {
					currentKey = ffjtHgncAttrLocation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHgncAttrLocusGroup, kn) {
					currentKey = ffjtHgncAttrLocusGroup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHgncAttrSymbols, kn) {
					currentKey = ffjtHgncAttrSymbols
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHgncAttrNames, kn) {
					currentKey = ffjtHgncAttrNames
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtHgncAttrnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtHgncAttrNames:
					goto handle_Names

				case ffjtHgncAttrSymbols:
					goto handle_Symbols

				case ffjtHgncAttrLocusGroup:
					goto handle_LocusGroup

				case ffjtHgncAttrLocation:
					goto handle_Location

				case ffjtHgncAttrAliases:
					goto handle_Aliases

				case ffjtHgncAttrLocusType:
					goto handle_LocusType

				case ffjtHgncAttrPrevNames:
					goto handle_PrevNames

				case ffjtHgncAttrPrevSymbols:
					goto handle_PrevSymbols

				case ffjtHgncAttrStatus:
					goto handle_Status

				case ffjtHgncAttrGeneGroups:
					goto handle_GeneGroups

				case ffjtHgncAttrnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Names:

	/* handler: j.Names type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Names = nil
		} else {

			j.Names = []string{}

			wantVal := true

			for {

				var tmpJNames string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJNames type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJNames = string(string(outBuf))

					}
				}

				j.Names = append(j.Names, tmpJNames)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Symbols:

	/* handler: j.Symbols type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Symbols = nil
		} else {

			j.Symbols = []string{}

			wantVal := true

			for {

				var tmpJSymbols string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJSymbols type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJSymbols = string(string(outBuf))

					}
				}

				j.Symbols = append(j.Symbols, tmpJSymbols)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LocusGroup:

	/* handler: j.LocusGroup type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LocusGroup = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Location:

	/* handler: j.Location type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Location = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Aliases:

	/* handler: j.Aliases type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Aliases = nil
		} else {

			j.Aliases = []string{}

			wantVal := true

			for {

				var tmpJAliases string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJAliases type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJAliases = string(string(outBuf))

					}
				}

				j.Aliases = append(j.Aliases, tmpJAliases)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LocusType:

	/* handler: j.LocusType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LocusType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PrevNames:

	/* handler: j.PrevNames type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.PrevNames = nil
		} else {

			j.PrevNames = []string{}

			wantVal := true

			for {

				var tmpJPrevNames string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJPrevNames type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJPrevNames = string(string(outBuf))

					}
				}

				j.PrevNames = append(j.PrevNames, tmpJPrevNames)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PrevSymbols:

	/* handler: j.PrevSymbols type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.PrevSymbols = nil
		} else {

			j.PrevSymbols = []string{}

			wantVal := true

			for {

				var tmpJPrevSymbols string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJPrevSymbols type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJPrevSymbols = string(string(outBuf))

					}
				}

				j.PrevSymbols = append(j.PrevSymbols, tmpJPrevSymbols)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Status:

	/* handler: j.Status type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Status = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GeneGroups:

	/* handler: j.GeneGroups type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.GeneGroups = nil
		} else {

			j.GeneGroups = []string{}

			wantVal := true

			for {

				var tmpJGeneGroups string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJGeneGroups type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJGeneGroups = string(string(outBuf))

					}
				}

				j.GeneGroups = append(j.GeneGroups, tmpJGeneGroups)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *HmdbAttr) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *HmdbAttr) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.Name) != 0 {
		buf.WriteString(`"name":`)
		fflib.WriteJsonString(buf, string(j.Name))
		buf.WriteByte(',')
	}
	if len(j.Desc) != 0 {
		buf.WriteString(`"desc":`)
		fflib.WriteJsonString(buf, string(j.Desc))
		buf.WriteByte(',')
	}
	if len(j.Accessions) != 0 {
		buf.WriteString(`"accessions":`)
		if j.Accessions != nil {
			buf.WriteString(`[`)
			for i, v := range j.Accessions {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Synonyms) != 0 {
		buf.WriteString(`"synonyms":`)
		if j.Synonyms != nil {
			buf.WriteString(`[`)
			for i, v := range j.Synonyms {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Diseases) != 0 {
		buf.WriteString(`"diseases":`)
		if j.Diseases != nil {
			buf.WriteString(`[`)
			for i, v := range j.Diseases {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Formula) != 0 {
		buf.WriteString(`"formula":`)
		fflib.WriteJsonString(buf, string(j.Formula))
		buf.WriteByte(',')
	}
	if j.AverageWeight != 0 {
		buf.WriteString(`"averageWeight":`)
		fflib.AppendFloat(buf, float64(j.AverageWeight), 'g', -1, 64)
		buf.WriteByte(',')
	}
	if j.MonisotopicWeight != 0 {
		buf.WriteString(`"monisotopicWeight":`)
		fflib.AppendFloat(buf, float64(j.MonisotopicWeight), 'g', -1, 64)
		buf.WriteByte(',')
	}
	if len(j.IupacName) != 0 {
		buf.WriteString(`"iupacName":`)
		fflib.WriteJsonString(buf, string(j.IupacName))
		buf.WriteByte(',')
	}
	if len(j.Smiles) != 0 {
		buf.WriteString(`"smiles":`)
		fflib.WriteJsonString(buf, string(j.Smiles))
		buf.WriteByte(',')
	}
	if len(j.Inchi) != 0 {
		buf.WriteString(`"inchi":`)
		fflib.WriteJsonString(buf, string(j.Inchi))
		buf.WriteByte(',')
	}
	if len(j.InchiKey) != 0 {
		buf.WriteString(`"inchiKey":`)
		fflib.WriteJsonString(buf, string(j.InchiKey))
		buf.WriteByte(',')
	}
	if j.Props != nil {
		if true {
			buf.WriteString(`"props":`)

			{

				err = j.Props.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.ExperimentalProps != nil {
		if true {
			buf.WriteString(`"experimentalProps":`)

			{

				err = j.ExperimentalProps.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.CellularLocations) != 0 {
		buf.WriteString(`"cellularLocations":`)
		if j.CellularLocations != nil {
			buf.WriteString(`[`)
			for i, v := range j.CellularLocations {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Biospecimens) != 0 {
		buf.WriteString(`"biospecimens":`)
		if j.Biospecimens != nil {
			buf.WriteString(`[`)
			for i, v := range j.Biospecimens {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.TissueLocations) != 0 {
		buf.WriteString(`"tissueLocations":`)
		if j.TissueLocations != nil {
			buf.WriteString(`[`)
			for i, v := range j.TissueLocations {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Pathways) != 0 {
		buf.WriteString(`"pathways":`)
		if j.Pathways != nil {
			buf.WriteString(`[`)
			for i, v := range j.Pathways {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtHmdbAttrbase = iota
	ffjtHmdbAttrnosuchkey

	ffjtHmdbAttrName

	ffjtHmdbAttrDesc

	ffjtHmdbAttrAccessions

	ffjtHmdbAttrSynonyms

	ffjtHmdbAttrDiseases

	ffjtHmdbAttrFormula

	ffjtHmdbAttrAverageWeight

	ffjtHmdbAttrMonisotopicWeight

	ffjtHmdbAttrIupacName

	ffjtHmdbAttrSmiles

	ffjtHmdbAttrInchi

	ffjtHmdbAttrInchiKey

	ffjtHmdbAttrProps

	ffjtHmdbAttrExperimentalProps

	ffjtHmdbAttrCellularLocations

	ffjtHmdbAttrBiospecimens

	ffjtHmdbAttrTissueLocations

	ffjtHmdbAttrPathways
)

var ffjKeyHmdbAttrName = []byte("name")

var ffjKeyHmdbAttrDesc = []byte("desc")

var ffjKeyHmdbAttrAccessions = []byte("accessions")

var ffjKeyHmdbAttrSynonyms = []byte("synonyms")

var ffjKeyHmdbAttrDiseases = []byte("diseases")

var ffjKeyHmdbAttrFormula = []byte("formula")

var ffjKeyHmdbAttrAverageWeight = []byte("averageWeight")

var ffjKeyHmdbAttrMonisotopicWeight = []byte("monisotopicWeight")

var ffjKeyHmdbAttrIupacName = []byte("iupacName")

var ffjKeyHmdbAttrSmiles = []byte("smiles")

var ffjKeyHmdbAttrInchi = []byte("inchi")

var ffjKeyHmdbAttrInchiKey = []byte("inchiKey")

var ffjKeyHmdbAttrProps = []byte("props")

var ffjKeyHmdbAttrExperimentalProps = []byte("experimentalProps")

var ffjKeyHmdbAttrCellularLocations = []byte("cellularLocations")

var ffjKeyHmdbAttrBiospecimens = []byte("biospecimens")

var ffjKeyHmdbAttrTissueLocations = []byte("tissueLocations")

var ffjKeyHmdbAttrPathways = []byte("pathways")

// UnmarshalJSON umarshall json - template of ffjson
func (j *HmdbAttr) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *HmdbAttr) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtHmdbAttrbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtHmdbAttrnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyHmdbAttrAccessions, kn) {
						currentKey = ffjtHmdbAttrAccessions
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyHmdbAttrAverageWeight, kn) {
						currentKey = ffjtHmdbAttrAverageWeight
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'b':

					if bytes.Equal(ffjKeyHmdbAttrBiospecimens, kn) {
						currentKey = ffjtHmdbAttrBiospecimens
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyHmdbAttrCellularLocations, kn) {
						currentKey = ffjtHmdbAttrCellularLocations
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyHmdbAttrDesc, kn) {
						currentKey = ffjtHmdbAttrDesc
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyHmdbAttrDiseases, kn) {
						currentKey = ffjtHmdbAttrDiseases
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyHmdbAttrExperimentalProps, kn) {
						currentKey = ffjtHmdbAttrExperimentalProps
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyHmdbAttrFormula, kn) {
						currentKey = ffjtHmdbAttrFormula
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyHmdbAttrIupacName, kn) {
						currentKey = ffjtHmdbAttrIupacName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyHmdbAttrInchi, kn) {
						currentKey = ffjtHmdbAttrInchi
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyHmdbAttrInchiKey, kn) {
						currentKey = ffjtHmdbAttrInchiKey
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyHmdbAttrMonisotopicWeight, kn) {
						currentKey = ffjtHmdbAttrMonisotopicWeight
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyHmdbAttrName, kn) {
						currentKey = ffjtHmdbAttrName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyHmdbAttrProps, kn) {
						currentKey = ffjtHmdbAttrProps
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyHmdbAttrPathways, kn) {
						currentKey = ffjtHmdbAttrPathways
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyHmdbAttrSynonyms, kn) {
						currentKey = ffjtHmdbAttrSynonyms
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyHmdbAttrSmiles, kn) {
						currentKey = ffjtHmdbAttrSmiles
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyHmdbAttrTissueLocations, kn) {
						currentKey = ffjtHmdbAttrTissueLocations
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyHmdbAttrPathways, kn) {
					currentKey = ffjtHmdbAttrPathways
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHmdbAttrTissueLocations, kn) {
					currentKey = ffjtHmdbAttrTissueLocations
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHmdbAttrBiospecimens, kn) {
					currentKey = ffjtHmdbAttrBiospecimens
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHmdbAttrCellularLocations, kn) {
					currentKey = ffjtHmdbAttrCellularLocations
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHmdbAttrExperimentalProps, kn) {
					currentKey = ffjtHmdbAttrExperimentalProps
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHmdbAttrProps, kn) {
					currentKey = ffjtHmdbAttrProps
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHmdbAttrInchiKey, kn) {
					currentKey = ffjtHmdbAttrInchiKey
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyHmdbAttrInchi, kn) {
					currentKey = ffjtHmdbAttrInchi
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHmdbAttrSmiles, kn) {
					currentKey = ffjtHmdbAttrSmiles
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyHmdbAttrIupacName, kn) {
					currentKey = ffjtHmdbAttrIupacName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHmdbAttrMonisotopicWeight, kn) {
					currentKey = ffjtHmdbAttrMonisotopicWeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyHmdbAttrAverageWeight, kn) {
					currentKey = ffjtHmdbAttrAverageWeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyHmdbAttrFormula, kn) {
					currentKey = ffjtHmdbAttrFormula
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHmdbAttrDiseases, kn) {
					currentKey = ffjtHmdbAttrDiseases
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHmdbAttrSynonyms, kn) {
					currentKey = ffjtHmdbAttrSynonyms
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHmdbAttrAccessions, kn) {
					currentKey = ffjtHmdbAttrAccessions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHmdbAttrDesc, kn) {
					currentKey = ffjtHmdbAttrDesc
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyHmdbAttrName, kn) {
					currentKey = ffjtHmdbAttrName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtHmdbAttrnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtHmdbAttrName:
					goto handle_Name

				case ffjtHmdbAttrDesc:
					goto handle_Desc

				case ffjtHmdbAttrAccessions:
					goto handle_Accessions

				case ffjtHmdbAttrSynonyms:
					goto handle_Synonyms

				case ffjtHmdbAttrDiseases:
					goto handle_Diseases

				case ffjtHmdbAttrFormula:
					goto handle_Formula

				case ffjtHmdbAttrAverageWeight:
					goto handle_AverageWeight

				case ffjtHmdbAttrMonisotopicWeight:
					goto handle_MonisotopicWeight

				case ffjtHmdbAttrIupacName:
					goto handle_IupacName

				case ffjtHmdbAttrSmiles:
					goto handle_Smiles

				case ffjtHmdbAttrInchi:
					goto handle_Inchi

				case ffjtHmdbAttrInchiKey:
					goto handle_InchiKey

				case ffjtHmdbAttrProps:
					goto handle_Props

				case ffjtHmdbAttrExperimentalProps:
					goto handle_ExperimentalProps

				case ffjtHmdbAttrCellularLocations:
					goto handle_CellularLocations

				case ffjtHmdbAttrBiospecimens:
					goto handle_Biospecimens

				case ffjtHmdbAttrTissueLocations:
					goto handle_TissueLocations

				case ffjtHmdbAttrPathways:
					goto handle_Pathways

				case ffjtHmdbAttrnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Desc:

	/* handler: j.Desc type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Desc = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Accessions:

	/* handler: j.Accessions type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Accessions = nil
		} else {

			j.Accessions = []string{}

			wantVal := true

			for {

				var tmpJAccessions string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJAccessions type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJAccessions = string(string(outBuf))

					}
				}

				j.Accessions = append(j.Accessions, tmpJAccessions)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Synonyms:

	/* handler: j.Synonyms type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Synonyms = nil
		} else {

			j.Synonyms = []string{}

			wantVal := true

			for {

				var tmpJSynonyms string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJSynonyms type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJSynonyms = string(string(outBuf))

					}
				}

				j.Synonyms = append(j.Synonyms, tmpJSynonyms)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Diseases:

	/* handler: j.Diseases type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Diseases = nil
		} else {

			j.Diseases = []string{}

			wantVal := true

			for {

				var tmpJDiseases string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJDiseases type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJDiseases = string(string(outBuf))

					}
				}

				j.Diseases = append(j.Diseases, tmpJDiseases)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Formula:

	/* handler: j.Formula type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Formula = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AverageWeight:

	/* handler: j.AverageWeight type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.AverageWeight = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MonisotopicWeight:

	/* handler: j.MonisotopicWeight type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MonisotopicWeight = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IupacName:

	/* handler: j.IupacName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.IupacName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Smiles:

	/* handler: j.Smiles type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Smiles = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Inchi:

	/* handler: j.Inchi type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Inchi = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InchiKey:

	/* handler: j.InchiKey type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.InchiKey = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Props:

	/* handler: j.Props type=pbuf.HmdbPredictedProps kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Props = nil

		} else {

			if j.Props == nil {
				j.Props = new(HmdbPredictedProps)
			}

			err = j.Props.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExperimentalProps:

	/* handler: j.ExperimentalProps type=pbuf.HmdbExperimentalProps kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ExperimentalProps = nil

		} else {

			if j.ExperimentalProps == nil {
				j.ExperimentalProps = new(HmdbExperimentalProps)
			}

			err = j.ExperimentalProps.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CellularLocations:

	/* handler: j.CellularLocations type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.CellularLocations = nil
		} else {

			j.CellularLocations = []string{}

			wantVal := true

			for {

				var tmpJCellularLocations string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJCellularLocations type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJCellularLocations = string(string(outBuf))

					}
				}

				j.CellularLocations = append(j.CellularLocations, tmpJCellularLocations)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Biospecimens:

	/* handler: j.Biospecimens type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Biospecimens = nil
		} else {

			j.Biospecimens = []string{}

			wantVal := true

			for {

				var tmpJBiospecimens string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJBiospecimens type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJBiospecimens = string(string(outBuf))

					}
				}

				j.Biospecimens = append(j.Biospecimens, tmpJBiospecimens)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TissueLocations:

	/* handler: j.TissueLocations type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.TissueLocations = nil
		} else {

			j.TissueLocations = []string{}

			wantVal := true

			for {

				var tmpJTissueLocations string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJTissueLocations type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJTissueLocations = string(string(outBuf))

					}
				}

				j.TissueLocations = append(j.TissueLocations, tmpJTissueLocations)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Pathways:

	/* handler: j.Pathways type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Pathways = nil
		} else {

			j.Pathways = []string{}

			wantVal := true

			for {

				var tmpJPathways string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJPathways type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJPathways = string(string(outBuf))

					}
				}

				j.Pathways = append(j.Pathways, tmpJPathways)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *HmdbExperimentalProps) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *HmdbExperimentalProps) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.BoolingPoint) != 0 {
		buf.WriteString(`"boolingPoint":`)
		fflib.WriteJsonString(buf, string(j.BoolingPoint))
		buf.WriteByte(',')
	}
	if len(j.MeltingPoint) != 0 {
		buf.WriteString(`"meltingPoint":`)
		fflib.WriteJsonString(buf, string(j.MeltingPoint))
		buf.WriteByte(',')
	}
	if j.Logp != 0 {
		buf.WriteString(`"logp":`)
		fflib.AppendFloat(buf, float64(j.Logp), 'g', -1, 64)
		buf.WriteByte(',')
	}
	if len(j.WaterSolubility) != 0 {
		buf.WriteString(`"waterSolubility":`)
		fflib.WriteJsonString(buf, string(j.WaterSolubility))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtHmdbExperimentalPropsbase = iota
	ffjtHmdbExperimentalPropsnosuchkey

	ffjtHmdbExperimentalPropsBoolingPoint

	ffjtHmdbExperimentalPropsMeltingPoint

	ffjtHmdbExperimentalPropsLogp

	ffjtHmdbExperimentalPropsWaterSolubility
)

var ffjKeyHmdbExperimentalPropsBoolingPoint = []byte("boolingPoint")

var ffjKeyHmdbExperimentalPropsMeltingPoint = []byte("meltingPoint")

var ffjKeyHmdbExperimentalPropsLogp = []byte("logp")

var ffjKeyHmdbExperimentalPropsWaterSolubility = []byte("waterSolubility")

// UnmarshalJSON umarshall json - template of ffjson
func (j *HmdbExperimentalProps) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *HmdbExperimentalProps) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtHmdbExperimentalPropsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtHmdbExperimentalPropsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffjKeyHmdbExperimentalPropsBoolingPoint, kn) {
						currentKey = ffjtHmdbExperimentalPropsBoolingPoint
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyHmdbExperimentalPropsLogp, kn) {
						currentKey = ffjtHmdbExperimentalPropsLogp
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyHmdbExperimentalPropsMeltingPoint, kn) {
						currentKey = ffjtHmdbExperimentalPropsMeltingPoint
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyHmdbExperimentalPropsWaterSolubility, kn) {
						currentKey = ffjtHmdbExperimentalPropsWaterSolubility
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyHmdbExperimentalPropsWaterSolubility, kn) {
					currentKey = ffjtHmdbExperimentalPropsWaterSolubility
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyHmdbExperimentalPropsLogp, kn) {
					currentKey = ffjtHmdbExperimentalPropsLogp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyHmdbExperimentalPropsMeltingPoint, kn) {
					currentKey = ffjtHmdbExperimentalPropsMeltingPoint
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyHmdbExperimentalPropsBoolingPoint, kn) {
					currentKey = ffjtHmdbExperimentalPropsBoolingPoint
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtHmdbExperimentalPropsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtHmdbExperimentalPropsBoolingPoint:
					goto handle_BoolingPoint

				case ffjtHmdbExperimentalPropsMeltingPoint:
					goto handle_MeltingPoint

				case ffjtHmdbExperimentalPropsLogp:
					goto handle_Logp

				case ffjtHmdbExperimentalPropsWaterSolubility:
					goto handle_WaterSolubility

				case ffjtHmdbExperimentalPropsnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_BoolingPoint:

	/* handler: j.BoolingPoint type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.BoolingPoint = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MeltingPoint:

	/* handler: j.MeltingPoint type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MeltingPoint = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Logp:

	/* handler: j.Logp type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Logp = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WaterSolubility:

	/* handler: j.WaterSolubility type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.WaterSolubility = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *HmdbPredictedProps) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *HmdbPredictedProps) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if j.RotatableBondCount != 0 {
		buf.WriteString(`"rotatableBondCount":`)
		fflib.FormatBits2(buf, uint64(j.RotatableBondCount), 10, j.RotatableBondCount < 0)
		buf.WriteByte(',')
	}
	if j.PhysiologicalCharge != 0 {
		buf.WriteString(`"physiologicalCharge":`)
		fflib.FormatBits2(buf, uint64(j.PhysiologicalCharge), 10, j.PhysiologicalCharge < 0)
		buf.WriteByte(',')
	}
	if len(j.RuleOfFive) != 0 {
		buf.WriteString(`"ruleOfFive":`)
		fflib.WriteJsonString(buf, string(j.RuleOfFive))
		buf.WriteByte(',')
	}
	if j.PkaStrongestAcidic != 0 {
		buf.WriteString(`"pkaStrongestAcidic":`)
		fflib.AppendFloat(buf, float64(j.PkaStrongestAcidic), 'g', -1, 64)
		buf.WriteByte(',')
	}
	if j.MonoMass != 0 {
		buf.WriteString(`"monoMass":`)
		fflib.AppendFloat(buf, float64(j.MonoMass), 'g', -1, 64)
		buf.WriteByte(',')
	}
	if len(j.GhoseFilter) != 0 {
		buf.WriteString(`"ghose_filter":`)
		fflib.WriteJsonString(buf, string(j.GhoseFilter))
		buf.WriteByte(',')
	}
	if j.Refractivity != 0 {
		buf.WriteString(`"refractivity":`)
		fflib.AppendFloat(buf, float64(j.Refractivity), 'g', -1, 64)
		buf.WriteByte(',')
	}
	if j.FormalCharge != 0 {
		buf.WriteString(`"formalCharge":`)
		fflib.AppendFloat(buf, float64(j.FormalCharge), 'g', -1, 64)
		buf.WriteByte(',')
	}
	if len(j.Bioavailability) != 0 {
		buf.WriteString(`"bioavailability":`)
		fflib.WriteJsonString(buf, string(j.Bioavailability))
		buf.WriteByte(',')
	}
	if len(j.Solubility) != 0 {
		buf.WriteString(`"solubility":`)
		fflib.WriteJsonString(buf, string(j.Solubility))
		buf.WriteByte(',')
	}
	if j.PkaStrongestBasic != 0 {
		buf.WriteString(`"pka_strongest_basic":`)
		fflib.AppendFloat(buf, float64(j.PkaStrongestBasic), 'g', -1, 64)
		buf.WriteByte(',')
	}
	if j.PolarSurfaceArea != 0 {
		buf.WriteString(`"polarSurfaceArea":`)
		fflib.AppendFloat(buf, float64(j.PolarSurfaceArea), 'g', -1, 64)
		buf.WriteByte(',')
	}
	if len(j.VeberRule) != 0 {
		buf.WriteString(`"veberRule":`)
		fflib.WriteJsonString(buf, string(j.VeberRule))
		buf.WriteByte(',')
	}
	if len(j.MddrLikeRule) != 0 {
		buf.WriteString(`"mddrLikeRule":`)
		fflib.WriteJsonString(buf, string(j.MddrLikeRule))
		buf.WriteByte(',')
	}
	if j.Logp != 0 {
		buf.WriteString(`"logp":`)
		fflib.AppendFloat(buf, float64(j.Logp), 'g', -1, 64)
		buf.WriteByte(',')
	}
	if j.Polarizability != 0 {
		buf.WriteString(`"polarizability":`)
		fflib.AppendFloat(buf, float64(j.Polarizability), 'g', -1, 64)
		buf.WriteByte(',')
	}
	if j.DonorCount != 0 {
		buf.WriteString(`"donorCount":`)
		fflib.FormatBits2(buf, uint64(j.DonorCount), 10, j.DonorCount < 0)
		buf.WriteByte(',')
	}
	if j.AverageMass != 0 {
		buf.WriteString(`"averageMass":`)
		fflib.AppendFloat(buf, float64(j.AverageMass), 'g', -1, 64)
		buf.WriteByte(',')
	}
	if j.AcceptorCount != 0 {
		buf.WriteString(`"acceptorCount":`)
		fflib.FormatBits2(buf, uint64(j.AcceptorCount), 10, j.AcceptorCount < 0)
		buf.WriteByte(',')
	}
	if j.NumberOfRings != 0 {
		buf.WriteString(`"numberOfRings":`)
		fflib.FormatBits2(buf, uint64(j.NumberOfRings), 10, j.NumberOfRings < 0)
		buf.WriteByte(',')
	}
	if j.Logs != 0 {
		buf.WriteString(`"logs":`)
		fflib.AppendFloat(buf, float64(j.Logs), 'g', -1, 64)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtHmdbPredictedPropsbase = iota
	ffjtHmdbPredictedPropsnosuchkey

	ffjtHmdbPredictedPropsRotatableBondCount

	ffjtHmdbPredictedPropsPhysiologicalCharge

	ffjtHmdbPredictedPropsRuleOfFive

	ffjtHmdbPredictedPropsPkaStrongestAcidic

	ffjtHmdbPredictedPropsMonoMass

	ffjtHmdbPredictedPropsGhoseFilter

	ffjtHmdbPredictedPropsRefractivity

	ffjtHmdbPredictedPropsFormalCharge

	ffjtHmdbPredictedPropsBioavailability

	ffjtHmdbPredictedPropsSolubility

	ffjtHmdbPredictedPropsPkaStrongestBasic

	ffjtHmdbPredictedPropsPolarSurfaceArea

	ffjtHmdbPredictedPropsVeberRule

	ffjtHmdbPredictedPropsMddrLikeRule

	ffjtHmdbPredictedPropsLogp

	ffjtHmdbPredictedPropsPolarizability

	ffjtHmdbPredictedPropsDonorCount

	ffjtHmdbPredictedPropsAverageMass

	ffjtHmdbPredictedPropsAcceptorCount

	ffjtHmdbPredictedPropsNumberOfRings

	ffjtHmdbPredictedPropsLogs
)

var ffjKeyHmdbPredictedPropsRotatableBondCount = []byte("rotatableBondCount")

var ffjKeyHmdbPredictedPropsPhysiologicalCharge = []byte("physiologicalCharge")

var ffjKeyHmdbPredictedPropsRuleOfFive = []byte("ruleOfFive")

var ffjKeyHmdbPredictedPropsPkaStrongestAcidic = []byte("pkaStrongestAcidic")

var ffjKeyHmdbPredictedPropsMonoMass = []byte("monoMass")

var ffjKeyHmdbPredictedPropsGhoseFilter = []byte("ghose_filter")

var ffjKeyHmdbPredictedPropsRefractivity = []byte("refractivity")

var ffjKeyHmdbPredictedPropsFormalCharge = []byte("formalCharge")

var ffjKeyHmdbPredictedPropsBioavailability = []byte("bioavailability")

var ffjKeyHmdbPredictedPropsSolubility = []byte("solubility")

var ffjKeyHmdbPredictedPropsPkaStrongestBasic = []byte("pka_strongest_basic")

var ffjKeyHmdbPredictedPropsPolarSurfaceArea = []byte("polarSurfaceArea")

var ffjKeyHmdbPredictedPropsVeberRule = []byte("veberRule")

var ffjKeyHmdbPredictedPropsMddrLikeRule = []byte("mddrLikeRule")

var ffjKeyHmdbPredictedPropsLogp = []byte("logp")

var ffjKeyHmdbPredictedPropsPolarizability = []byte("polarizability")

var ffjKeyHmdbPredictedPropsDonorCount = []byte("donorCount")

var ffjKeyHmdbPredictedPropsAverageMass = []byte("averageMass")

var ffjKeyHmdbPredictedPropsAcceptorCount = []byte("acceptorCount")

var ffjKeyHmdbPredictedPropsNumberOfRings = []byte("numberOfRings")

var ffjKeyHmdbPredictedPropsLogs = []byte("logs")

// UnmarshalJSON umarshall json - template of ffjson
func (j *HmdbPredictedProps) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *HmdbPredictedProps) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtHmdbPredictedPropsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtHmdbPredictedPropsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyHmdbPredictedPropsAverageMass, kn) {
						currentKey = ffjtHmdbPredictedPropsAverageMass
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyHmdbPredictedPropsAcceptorCount, kn) {
						currentKey = ffjtHmdbPredictedPropsAcceptorCount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'b':

					if bytes.Equal(ffjKeyHmdbPredictedPropsBioavailability, kn) {
						currentKey = ffjtHmdbPredictedPropsBioavailability
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyHmdbPredictedPropsDonorCount, kn) {
						currentKey = ffjtHmdbPredictedPropsDonorCount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyHmdbPredictedPropsFormalCharge, kn) {
						currentKey = ffjtHmdbPredictedPropsFormalCharge
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyHmdbPredictedPropsGhoseFilter, kn) {
						currentKey = ffjtHmdbPredictedPropsGhoseFilter
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyHmdbPredictedPropsLogp, kn) {
						currentKey = ffjtHmdbPredictedPropsLogp
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyHmdbPredictedPropsLogs, kn) {
						currentKey = ffjtHmdbPredictedPropsLogs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyHmdbPredictedPropsMonoMass, kn) {
						currentKey = ffjtHmdbPredictedPropsMonoMass
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyHmdbPredictedPropsMddrLikeRule, kn) {
						currentKey = ffjtHmdbPredictedPropsMddrLikeRule
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyHmdbPredictedPropsNumberOfRings, kn) {
						currentKey = ffjtHmdbPredictedPropsNumberOfRings
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyHmdbPredictedPropsPhysiologicalCharge, kn) {
						currentKey = ffjtHmdbPredictedPropsPhysiologicalCharge
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyHmdbPredictedPropsPkaStrongestAcidic, kn) {
						currentKey = ffjtHmdbPredictedPropsPkaStrongestAcidic
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyHmdbPredictedPropsPkaStrongestBasic, kn) {
						currentKey = ffjtHmdbPredictedPropsPkaStrongestBasic
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyHmdbPredictedPropsPolarSurfaceArea, kn) {
						currentKey = ffjtHmdbPredictedPropsPolarSurfaceArea
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyHmdbPredictedPropsPolarizability, kn) {
						currentKey = ffjtHmdbPredictedPropsPolarizability
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyHmdbPredictedPropsRotatableBondCount, kn) {
						currentKey = ffjtHmdbPredictedPropsRotatableBondCount
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyHmdbPredictedPropsRuleOfFive, kn) {
						currentKey = ffjtHmdbPredictedPropsRuleOfFive
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyHmdbPredictedPropsRefractivity, kn) {
						currentKey = ffjtHmdbPredictedPropsRefractivity
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyHmdbPredictedPropsSolubility, kn) {
						currentKey = ffjtHmdbPredictedPropsSolubility
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyHmdbPredictedPropsVeberRule, kn) {
						currentKey = ffjtHmdbPredictedPropsVeberRule
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyHmdbPredictedPropsLogs, kn) {
					currentKey = ffjtHmdbPredictedPropsLogs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHmdbPredictedPropsNumberOfRings, kn) {
					currentKey = ffjtHmdbPredictedPropsNumberOfRings
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyHmdbPredictedPropsAcceptorCount, kn) {
					currentKey = ffjtHmdbPredictedPropsAcceptorCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHmdbPredictedPropsAverageMass, kn) {
					currentKey = ffjtHmdbPredictedPropsAverageMass
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyHmdbPredictedPropsDonorCount, kn) {
					currentKey = ffjtHmdbPredictedPropsDonorCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyHmdbPredictedPropsPolarizability, kn) {
					currentKey = ffjtHmdbPredictedPropsPolarizability
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyHmdbPredictedPropsLogp, kn) {
					currentKey = ffjtHmdbPredictedPropsLogp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHmdbPredictedPropsMddrLikeRule, kn) {
					currentKey = ffjtHmdbPredictedPropsMddrLikeRule
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyHmdbPredictedPropsVeberRule, kn) {
					currentKey = ffjtHmdbPredictedPropsVeberRule
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHmdbPredictedPropsPolarSurfaceArea, kn) {
					currentKey = ffjtHmdbPredictedPropsPolarSurfaceArea
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHmdbPredictedPropsPkaStrongestBasic, kn) {
					currentKey = ffjtHmdbPredictedPropsPkaStrongestBasic
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHmdbPredictedPropsSolubility, kn) {
					currentKey = ffjtHmdbPredictedPropsSolubility
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyHmdbPredictedPropsBioavailability, kn) {
					currentKey = ffjtHmdbPredictedPropsBioavailability
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyHmdbPredictedPropsFormalCharge, kn) {
					currentKey = ffjtHmdbPredictedPropsFormalCharge
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyHmdbPredictedPropsRefractivity, kn) {
					currentKey = ffjtHmdbPredictedPropsRefractivity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHmdbPredictedPropsGhoseFilter, kn) {
					currentKey = ffjtHmdbPredictedPropsGhoseFilter
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHmdbPredictedPropsMonoMass, kn) {
					currentKey = ffjtHmdbPredictedPropsMonoMass
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHmdbPredictedPropsPkaStrongestAcidic, kn) {
					currentKey = ffjtHmdbPredictedPropsPkaStrongestAcidic
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyHmdbPredictedPropsRuleOfFive, kn) {
					currentKey = ffjtHmdbPredictedPropsRuleOfFive
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHmdbPredictedPropsPhysiologicalCharge, kn) {
					currentKey = ffjtHmdbPredictedPropsPhysiologicalCharge
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyHmdbPredictedPropsRotatableBondCount, kn) {
					currentKey = ffjtHmdbPredictedPropsRotatableBondCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtHmdbPredictedPropsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtHmdbPredictedPropsRotatableBondCount:
					goto handle_RotatableBondCount

				case ffjtHmdbPredictedPropsPhysiologicalCharge:
					goto handle_PhysiologicalCharge

				case ffjtHmdbPredictedPropsRuleOfFive:
					goto handle_RuleOfFive

				case ffjtHmdbPredictedPropsPkaStrongestAcidic:
					goto handle_PkaStrongestAcidic

				case ffjtHmdbPredictedPropsMonoMass:
					goto handle_MonoMass

				case ffjtHmdbPredictedPropsGhoseFilter:
					goto handle_GhoseFilter

				case ffjtHmdbPredictedPropsRefractivity:
					goto handle_Refractivity

				case ffjtHmdbPredictedPropsFormalCharge:
					goto handle_FormalCharge

				case ffjtHmdbPredictedPropsBioavailability:
					goto handle_Bioavailability

				case ffjtHmdbPredictedPropsSolubility:
					goto handle_Solubility

				case ffjtHmdbPredictedPropsPkaStrongestBasic:
					goto handle_PkaStrongestBasic

				case ffjtHmdbPredictedPropsPolarSurfaceArea:
					goto handle_PolarSurfaceArea

				case ffjtHmdbPredictedPropsVeberRule:
					goto handle_VeberRule

				case ffjtHmdbPredictedPropsMddrLikeRule:
					goto handle_MddrLikeRule

				case ffjtHmdbPredictedPropsLogp:
					goto handle_Logp

				case ffjtHmdbPredictedPropsPolarizability:
					goto handle_Polarizability

				case ffjtHmdbPredictedPropsDonorCount:
					goto handle_DonorCount

				case ffjtHmdbPredictedPropsAverageMass:
					goto handle_AverageMass

				case ffjtHmdbPredictedPropsAcceptorCount:
					goto handle_AcceptorCount

				case ffjtHmdbPredictedPropsNumberOfRings:
					goto handle_NumberOfRings

				case ffjtHmdbPredictedPropsLogs:
					goto handle_Logs

				case ffjtHmdbPredictedPropsnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_RotatableBondCount:

	/* handler: j.RotatableBondCount type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.RotatableBondCount = int32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PhysiologicalCharge:

	/* handler: j.PhysiologicalCharge type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.PhysiologicalCharge = int32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RuleOfFive:

	/* handler: j.RuleOfFive type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.RuleOfFive = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PkaStrongestAcidic:

	/* handler: j.PkaStrongestAcidic type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.PkaStrongestAcidic = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MonoMass:

	/* handler: j.MonoMass type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MonoMass = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GhoseFilter:

	/* handler: j.GhoseFilter type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.GhoseFilter = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Refractivity:

	/* handler: j.Refractivity type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Refractivity = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FormalCharge:

	/* handler: j.FormalCharge type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FormalCharge = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Bioavailability:

	/* handler: j.Bioavailability type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Bioavailability = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Solubility:

	/* handler: j.Solubility type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Solubility = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PkaStrongestBasic:

	/* handler: j.PkaStrongestBasic type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.PkaStrongestBasic = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PolarSurfaceArea:

	/* handler: j.PolarSurfaceArea type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.PolarSurfaceArea = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VeberRule:

	/* handler: j.VeberRule type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.VeberRule = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MddrLikeRule:

	/* handler: j.MddrLikeRule type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MddrLikeRule = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Logp:

	/* handler: j.Logp type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Logp = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Polarizability:

	/* handler: j.Polarizability type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Polarizability = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DonorCount:

	/* handler: j.DonorCount type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.DonorCount = int32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AverageMass:

	/* handler: j.AverageMass type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.AverageMass = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AcceptorCount:

	/* handler: j.AcceptorCount type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.AcceptorCount = int32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NumberOfRings:

	/* handler: j.NumberOfRings type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.NumberOfRings = int32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Logs:

	/* handler: j.Logs type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Logs = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InterproAttr) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InterproAttr) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.Names) != 0 {
		buf.WriteString(`"names":`)
		if j.Names != nil {
			buf.WriteString(`[`)
			for i, v := range j.Names {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.ShortName) != 0 {
		buf.WriteString(`"short_name":`)
		fflib.WriteJsonString(buf, string(j.ShortName))
		buf.WriteByte(',')
	}
	if len(j.Type) != 0 {
		buf.WriteString(`"type":`)
		fflib.WriteJsonString(buf, string(j.Type))
		buf.WriteByte(',')
	}
	if j.ProteinCount != 0 {
		buf.WriteString(`"protein_count":`)
		fflib.FormatBits2(buf, uint64(j.ProteinCount), 10, j.ProteinCount < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInterproAttrbase = iota
	ffjtInterproAttrnosuchkey

	ffjtInterproAttrNames

	ffjtInterproAttrShortName

	ffjtInterproAttrType

	ffjtInterproAttrProteinCount
)

var ffjKeyInterproAttrNames = []byte("names")

var ffjKeyInterproAttrShortName = []byte("short_name")

var ffjKeyInterproAttrType = []byte("type")

var ffjKeyInterproAttrProteinCount = []byte("protein_count")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InterproAttr) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InterproAttr) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInterproAttrbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInterproAttrnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'n':

					if bytes.Equal(ffjKeyInterproAttrNames, kn) {
						currentKey = ffjtInterproAttrNames
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyInterproAttrProteinCount, kn) {
						currentKey = ffjtInterproAttrProteinCount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyInterproAttrShortName, kn) {
						currentKey = ffjtInterproAttrShortName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInterproAttrType, kn) {
						currentKey = ffjtInterproAttrType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyInterproAttrProteinCount, kn) {
					currentKey = ffjtInterproAttrProteinCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInterproAttrType, kn) {
					currentKey = ffjtInterproAttrType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInterproAttrShortName, kn) {
					currentKey = ffjtInterproAttrShortName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInterproAttrNames, kn) {
					currentKey = ffjtInterproAttrNames
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInterproAttrnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInterproAttrNames:
					goto handle_Names

				case ffjtInterproAttrShortName:
					goto handle_ShortName

				case ffjtInterproAttrType:
					goto handle_Type

				case ffjtInterproAttrProteinCount:
					goto handle_ProteinCount

				case ffjtInterproAttrnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Names:

	/* handler: j.Names type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Names = nil
		} else {

			j.Names = []string{}

			wantVal := true

			for {

				var tmpJNames string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJNames type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJNames = string(string(outBuf))

					}
				}

				j.Names = append(j.Names, tmpJNames)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShortName:

	/* handler: j.ShortName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ShortName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProteinCount:

	/* handler: j.ProteinCount type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ProteinCount = int32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *OntologyAttr) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *OntologyAttr) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.Type) != 0 {
		buf.WriteString(`"type":`)
		fflib.WriteJsonString(buf, string(j.Type))
		buf.WriteByte(',')
	}
	if len(j.Name) != 0 {
		buf.WriteString(`"name":`)
		fflib.WriteJsonString(buf, string(j.Name))
		buf.WriteByte(',')
	}
	if len(j.Synonyms) != 0 {
		buf.WriteString(`"synonyms":`)
		if j.Synonyms != nil {
			buf.WriteString(`[`)
			for i, v := range j.Synonyms {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtOntologyAttrbase = iota
	ffjtOntologyAttrnosuchkey

	ffjtOntologyAttrType

	ffjtOntologyAttrName

	ffjtOntologyAttrSynonyms
)

var ffjKeyOntologyAttrType = []byte("type")

var ffjKeyOntologyAttrName = []byte("name")

var ffjKeyOntologyAttrSynonyms = []byte("synonyms")

// UnmarshalJSON umarshall json - template of ffjson
func (j *OntologyAttr) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *OntologyAttr) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtOntologyAttrbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtOntologyAttrnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'n':

					if bytes.Equal(ffjKeyOntologyAttrName, kn) {
						currentKey = ffjtOntologyAttrName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyOntologyAttrSynonyms, kn) {
						currentKey = ffjtOntologyAttrSynonyms
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyOntologyAttrType, kn) {
						currentKey = ffjtOntologyAttrType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyOntologyAttrSynonyms, kn) {
					currentKey = ffjtOntologyAttrSynonyms
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyOntologyAttrName, kn) {
					currentKey = ffjtOntologyAttrName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyOntologyAttrType, kn) {
					currentKey = ffjtOntologyAttrType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtOntologyAttrnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtOntologyAttrType:
					goto handle_Type

				case ffjtOntologyAttrName:
					goto handle_Name

				case ffjtOntologyAttrSynonyms:
					goto handle_Synonyms

				case ffjtOntologyAttrnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Synonyms:

	/* handler: j.Synonyms type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Synonyms = nil
		} else {

			j.Synonyms = []string{}

			wantVal := true

			for {

				var tmpJSynonyms string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJSynonyms type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJSynonyms = string(string(outBuf))

					}
				}

				j.Synonyms = append(j.Synonyms, tmpJSynonyms)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *OrphanetAttr) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *OrphanetAttr) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.Disease) != 0 {
		buf.WriteString(`"disease":`)
		fflib.WriteJsonString(buf, string(j.Disease))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtOrphanetAttrbase = iota
	ffjtOrphanetAttrnosuchkey

	ffjtOrphanetAttrDisease
)

var ffjKeyOrphanetAttrDisease = []byte("disease")

// UnmarshalJSON umarshall json - template of ffjson
func (j *OrphanetAttr) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *OrphanetAttr) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtOrphanetAttrbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtOrphanetAttrnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyOrphanetAttrDisease, kn) {
						currentKey = ffjtOrphanetAttrDisease
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyOrphanetAttrDisease, kn) {
					currentKey = ffjtOrphanetAttrDisease
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtOrphanetAttrnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtOrphanetAttrDisease:
					goto handle_Disease

				case ffjtOrphanetAttrnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Disease:

	/* handler: j.Disease type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Disease = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *PdbAttr) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *PdbAttr) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.Method) != 0 {
		buf.WriteString(`"method":`)
		fflib.WriteJsonString(buf, string(j.Method))
		buf.WriteByte(',')
	}
	if len(j.Chains) != 0 {
		buf.WriteString(`"chains":`)
		fflib.WriteJsonString(buf, string(j.Chains))
		buf.WriteByte(',')
	}
	if len(j.Resolution) != 0 {
		buf.WriteString(`"resolution":`)
		fflib.WriteJsonString(buf, string(j.Resolution))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPdbAttrbase = iota
	ffjtPdbAttrnosuchkey

	ffjtPdbAttrMethod

	ffjtPdbAttrChains

	ffjtPdbAttrResolution
)

var ffjKeyPdbAttrMethod = []byte("method")

var ffjKeyPdbAttrChains = []byte("chains")

var ffjKeyPdbAttrResolution = []byte("resolution")

// UnmarshalJSON umarshall json - template of ffjson
func (j *PdbAttr) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *PdbAttr) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPdbAttrbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPdbAttrnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyPdbAttrChains, kn) {
						currentKey = ffjtPdbAttrChains
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyPdbAttrMethod, kn) {
						currentKey = ffjtPdbAttrMethod
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyPdbAttrResolution, kn) {
						currentKey = ffjtPdbAttrResolution
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyPdbAttrResolution, kn) {
					currentKey = ffjtPdbAttrResolution
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPdbAttrChains, kn) {
					currentKey = ffjtPdbAttrChains
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPdbAttrMethod, kn) {
					currentKey = ffjtPdbAttrMethod
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPdbAttrnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPdbAttrMethod:
					goto handle_Method

				case ffjtPdbAttrChains:
					goto handle_Chains

				case ffjtPdbAttrResolution:
					goto handle_Resolution

				case ffjtPdbAttrnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Method:

	/* handler: j.Method type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Method = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Chains:

	/* handler: j.Chains type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Chains = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Resolution:

	/* handler: j.Resolution type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Resolution = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ReactomeAttr) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ReactomeAttr) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.Pathway) != 0 {
		buf.WriteString(`"pathway":`)
		fflib.WriteJsonString(buf, string(j.Pathway))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtReactomeAttrbase = iota
	ffjtReactomeAttrnosuchkey

	ffjtReactomeAttrPathway
)

var ffjKeyReactomeAttrPathway = []byte("pathway")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ReactomeAttr) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ReactomeAttr) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtReactomeAttrbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtReactomeAttrnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'p':

					if bytes.Equal(ffjKeyReactomeAttrPathway, kn) {
						currentKey = ffjtReactomeAttrPathway
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyReactomeAttrPathway, kn) {
					currentKey = ffjtReactomeAttrPathway
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtReactomeAttrnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtReactomeAttrPathway:
					goto handle_Pathway

				case ffjtReactomeAttrnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Pathway:

	/* handler: j.Pathway type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Pathway = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *TaxoAttr) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *TaxoAttr) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.Name) != 0 {
		buf.WriteString(`"name":`)
		fflib.WriteJsonString(buf, string(j.Name))
		buf.WriteByte(',')
	}
	if len(j.CommonName) != 0 {
		buf.WriteString(`"common_name":`)
		fflib.WriteJsonString(buf, string(j.CommonName))
		buf.WriteByte(',')
	}
	if j.Rank != 0 {
		buf.WriteString(`"rank":`)
		fflib.FormatBits2(buf, uint64(j.Rank), 10, j.Rank < 0)
		buf.WriteByte(',')
	}
	if len(j.TaxonomicDivision) != 0 {
		buf.WriteString(`"taxonomic_division":`)
		fflib.WriteJsonString(buf, string(j.TaxonomicDivision))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtTaxoAttrbase = iota
	ffjtTaxoAttrnosuchkey

	ffjtTaxoAttrName

	ffjtTaxoAttrCommonName

	ffjtTaxoAttrRank

	ffjtTaxoAttrTaxonomicDivision
)

var ffjKeyTaxoAttrName = []byte("name")

var ffjKeyTaxoAttrCommonName = []byte("common_name")

var ffjKeyTaxoAttrRank = []byte("rank")

var ffjKeyTaxoAttrTaxonomicDivision = []byte("taxonomic_division")

// UnmarshalJSON umarshall json - template of ffjson
func (j *TaxoAttr) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *TaxoAttr) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtTaxoAttrbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtTaxoAttrnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyTaxoAttrCommonName, kn) {
						currentKey = ffjtTaxoAttrCommonName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyTaxoAttrName, kn) {
						currentKey = ffjtTaxoAttrName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyTaxoAttrRank, kn) {
						currentKey = ffjtTaxoAttrRank
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyTaxoAttrTaxonomicDivision, kn) {
						currentKey = ffjtTaxoAttrTaxonomicDivision
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyTaxoAttrTaxonomicDivision, kn) {
					currentKey = ffjtTaxoAttrTaxonomicDivision
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyTaxoAttrRank, kn) {
					currentKey = ffjtTaxoAttrRank
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyTaxoAttrCommonName, kn) {
					currentKey = ffjtTaxoAttrCommonName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyTaxoAttrName, kn) {
					currentKey = ffjtTaxoAttrName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtTaxoAttrnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtTaxoAttrName:
					goto handle_Name

				case ffjtTaxoAttrCommonName:
					goto handle_CommonName

				case ffjtTaxoAttrRank:
					goto handle_Rank

				case ffjtTaxoAttrTaxonomicDivision:
					goto handle_TaxonomicDivision

				case ffjtTaxoAttrnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CommonName:

	/* handler: j.CommonName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.CommonName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Rank:

	/* handler: j.Rank type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Rank = int32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TaxonomicDivision:

	/* handler: j.TaxonomicDivision type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.TaxonomicDivision = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *UniLocation) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *UniLocation) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if j.Begin != 0 {
		buf.WriteString(`"begin":`)
		fflib.FormatBits2(buf, uint64(j.Begin), 10, j.Begin < 0)
		buf.WriteByte(',')
	}
	if j.End != 0 {
		buf.WriteString(`"end":`)
		fflib.FormatBits2(buf, uint64(j.End), 10, j.End < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtUniLocationbase = iota
	ffjtUniLocationnosuchkey

	ffjtUniLocationBegin

	ffjtUniLocationEnd
)

var ffjKeyUniLocationBegin = []byte("begin")

var ffjKeyUniLocationEnd = []byte("end")

// UnmarshalJSON umarshall json - template of ffjson
func (j *UniLocation) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *UniLocation) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtUniLocationbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtUniLocationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffjKeyUniLocationBegin, kn) {
						currentKey = ffjtUniLocationBegin
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyUniLocationEnd, kn) {
						currentKey = ffjtUniLocationEnd
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyUniLocationEnd, kn) {
					currentKey = ffjtUniLocationEnd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyUniLocationBegin, kn) {
					currentKey = ffjtUniLocationBegin
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtUniLocationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtUniLocationBegin:
					goto handle_Begin

				case ffjtUniLocationEnd:
					goto handle_End

				case ffjtUniLocationnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Begin:

	/* handler: j.Begin type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Begin = int32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_End:

	/* handler: j.End type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.End = int32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *UniSequence) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *UniSequence) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.Seq) != 0 {
		buf.WriteString(`"seq":`)
		fflib.WriteJsonString(buf, string(j.Seq))
		buf.WriteByte(',')
	}
	if j.Mass != 0 {
		buf.WriteString(`"mass":`)
		fflib.FormatBits2(buf, uint64(j.Mass), 10, j.Mass < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtUniSequencebase = iota
	ffjtUniSequencenosuchkey

	ffjtUniSequenceSeq

	ffjtUniSequenceMass
)

var ffjKeyUniSequenceSeq = []byte("seq")

var ffjKeyUniSequenceMass = []byte("mass")

// UnmarshalJSON umarshall json - template of ffjson
func (j *UniSequence) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *UniSequence) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtUniSequencebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtUniSequencenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'm':

					if bytes.Equal(ffjKeyUniSequenceMass, kn) {
						currentKey = ffjtUniSequenceMass
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyUniSequenceSeq, kn) {
						currentKey = ffjtUniSequenceSeq
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyUniSequenceMass, kn) {
					currentKey = ffjtUniSequenceMass
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUniSequenceSeq, kn) {
					currentKey = ffjtUniSequenceSeq
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtUniSequencenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtUniSequenceSeq:
					goto handle_Seq

				case ffjtUniSequenceMass:
					goto handle_Mass

				case ffjtUniSequencenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Seq:

	/* handler: j.Seq type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Seq = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mass:

	/* handler: j.Mass type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Mass = int32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *UniprotAttr) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *UniprotAttr) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.Accessions) != 0 {
		buf.WriteString(`"accessions":`)
		if j.Accessions != nil {
			buf.WriteString(`[`)
			for i, v := range j.Accessions {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Genes) != 0 {
		buf.WriteString(`"genes":`)
		if j.Genes != nil {
			buf.WriteString(`[`)
			for i, v := range j.Genes {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Names) != 0 {
		buf.WriteString(`"names":`)
		if j.Names != nil {
			buf.WriteString(`[`)
			for i, v := range j.Names {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.AlternativeNames) != 0 {
		buf.WriteString(`"alternative_names":`)
		if j.AlternativeNames != nil {
			buf.WriteString(`[`)
			for i, v := range j.AlternativeNames {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.SubmittedNames) != 0 {
		buf.WriteString(`"submitted_names":`)
		if j.SubmittedNames != nil {
			buf.WriteString(`[`)
			for i, v := range j.SubmittedNames {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if j.Sequence != nil {
		if true {
			buf.WriteString(`"sequence":`)

			{

				err = j.Sequence.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Reviewed != false {
		if j.Reviewed {
			buf.WriteString(`"reviewed":true`)
		} else {
			buf.WriteString(`"reviewed":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtUniprotAttrbase = iota
	ffjtUniprotAttrnosuchkey

	ffjtUniprotAttrAccessions

	ffjtUniprotAttrGenes

	ffjtUniprotAttrNames

	ffjtUniprotAttrAlternativeNames

	ffjtUniprotAttrSubmittedNames

	ffjtUniprotAttrSequence

	ffjtUniprotAttrReviewed
)

var ffjKeyUniprotAttrAccessions = []byte("accessions")

var ffjKeyUniprotAttrGenes = []byte("genes")

var ffjKeyUniprotAttrNames = []byte("names")

var ffjKeyUniprotAttrAlternativeNames = []byte("alternative_names")

var ffjKeyUniprotAttrSubmittedNames = []byte("submitted_names")

var ffjKeyUniprotAttrSequence = []byte("sequence")

var ffjKeyUniprotAttrReviewed = []byte("reviewed")

// UnmarshalJSON umarshall json - template of ffjson
func (j *UniprotAttr) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *UniprotAttr) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtUniprotAttrbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtUniprotAttrnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyUniprotAttrAccessions, kn) {
						currentKey = ffjtUniprotAttrAccessions
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUniprotAttrAlternativeNames, kn) {
						currentKey = ffjtUniprotAttrAlternativeNames
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyUniprotAttrGenes, kn) {
						currentKey = ffjtUniprotAttrGenes
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyUniprotAttrNames, kn) {
						currentKey = ffjtUniprotAttrNames
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyUniprotAttrReviewed, kn) {
						currentKey = ffjtUniprotAttrReviewed
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyUniprotAttrSubmittedNames, kn) {
						currentKey = ffjtUniprotAttrSubmittedNames
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUniprotAttrSequence, kn) {
						currentKey = ffjtUniprotAttrSequence
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyUniprotAttrReviewed, kn) {
					currentKey = ffjtUniprotAttrReviewed
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUniprotAttrSequence, kn) {
					currentKey = ffjtUniprotAttrSequence
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUniprotAttrSubmittedNames, kn) {
					currentKey = ffjtUniprotAttrSubmittedNames
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUniprotAttrAlternativeNames, kn) {
					currentKey = ffjtUniprotAttrAlternativeNames
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUniprotAttrNames, kn) {
					currentKey = ffjtUniprotAttrNames
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUniprotAttrGenes, kn) {
					currentKey = ffjtUniprotAttrGenes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUniprotAttrAccessions, kn) {
					currentKey = ffjtUniprotAttrAccessions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtUniprotAttrnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtUniprotAttrAccessions:
					goto handle_Accessions

				case ffjtUniprotAttrGenes:
					goto handle_Genes

				case ffjtUniprotAttrNames:
					goto handle_Names

				case ffjtUniprotAttrAlternativeNames:
					goto handle_AlternativeNames

				case ffjtUniprotAttrSubmittedNames:
					goto handle_SubmittedNames

				case ffjtUniprotAttrSequence:
					goto handle_Sequence

				case ffjtUniprotAttrReviewed:
					goto handle_Reviewed

				case ffjtUniprotAttrnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Accessions:

	/* handler: j.Accessions type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Accessions = nil
		} else {

			j.Accessions = []string{}

			wantVal := true

			for {

				var tmpJAccessions string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJAccessions type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJAccessions = string(string(outBuf))

					}
				}

				j.Accessions = append(j.Accessions, tmpJAccessions)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Genes:

	/* handler: j.Genes type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Genes = nil
		} else {

			j.Genes = []string{}

			wantVal := true

			for {

				var tmpJGenes string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJGenes type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJGenes = string(string(outBuf))

					}
				}

				j.Genes = append(j.Genes, tmpJGenes)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Names:

	/* handler: j.Names type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Names = nil
		} else {

			j.Names = []string{}

			wantVal := true

			for {

				var tmpJNames string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJNames type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJNames = string(string(outBuf))

					}
				}

				j.Names = append(j.Names, tmpJNames)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AlternativeNames:

	/* handler: j.AlternativeNames type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.AlternativeNames = nil
		} else {

			j.AlternativeNames = []string{}

			wantVal := true

			for {

				var tmpJAlternativeNames string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJAlternativeNames type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJAlternativeNames = string(string(outBuf))

					}
				}

				j.AlternativeNames = append(j.AlternativeNames, tmpJAlternativeNames)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SubmittedNames:

	/* handler: j.SubmittedNames type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.SubmittedNames = nil
		} else {

			j.SubmittedNames = []string{}

			wantVal := true

			for {

				var tmpJSubmittedNames string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJSubmittedNames type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJSubmittedNames = string(string(outBuf))

					}
				}

				j.SubmittedNames = append(j.SubmittedNames, tmpJSubmittedNames)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Sequence:

	/* handler: j.Sequence type=pbuf.UniSequence kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Sequence = nil

		} else {

			if j.Sequence == nil {
				j.Sequence = new(UniSequence)
			}

			err = j.Sequence.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Reviewed:

	/* handler: j.Reviewed type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Reviewed = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Reviewed = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *UniprotFeatureAttr) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *UniprotFeatureAttr) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.Type) != 0 {
		buf.WriteString(`"type":`)
		fflib.WriteJsonString(buf, string(j.Type))
		buf.WriteByte(',')
	}
	if len(j.Description) != 0 {
		buf.WriteString(`"description":`)
		fflib.WriteJsonString(buf, string(j.Description))
		buf.WriteByte(',')
	}
	if len(j.Id) != 0 {
		buf.WriteString(`"id":`)
		fflib.WriteJsonString(buf, string(j.Id))
		buf.WriteByte(',')
	}
	if len(j.Evidences) != 0 {
		buf.WriteString(`"evidences":`)
		if j.Evidences != nil {
			buf.WriteString(`[`)
			for i, v := range j.Evidences {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
					} else {

						err = v.MarshalJSONBuf(buf)
						if err != nil {
							return err
						}

					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Original) != 0 {
		buf.WriteString(`"original":`)
		fflib.WriteJsonString(buf, string(j.Original))
		buf.WriteByte(',')
	}
	if len(j.Variation) != 0 {
		buf.WriteString(`"variation":`)
		fflib.WriteJsonString(buf, string(j.Variation))
		buf.WriteByte(',')
	}
	if j.Location != nil {
		if true {
			buf.WriteString(`"location":`)

			{

				err = j.Location.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtUniprotFeatureAttrbase = iota
	ffjtUniprotFeatureAttrnosuchkey

	ffjtUniprotFeatureAttrType

	ffjtUniprotFeatureAttrDescription

	ffjtUniprotFeatureAttrId

	ffjtUniprotFeatureAttrEvidences

	ffjtUniprotFeatureAttrOriginal

	ffjtUniprotFeatureAttrVariation

	ffjtUniprotFeatureAttrLocation
)

var ffjKeyUniprotFeatureAttrType = []byte("type")

var ffjKeyUniprotFeatureAttrDescription = []byte("description")

var ffjKeyUniprotFeatureAttrId = []byte("id")

var ffjKeyUniprotFeatureAttrEvidences = []byte("evidences")

var ffjKeyUniprotFeatureAttrOriginal = []byte("original")

var ffjKeyUniprotFeatureAttrVariation = []byte("variation")

var ffjKeyUniprotFeatureAttrLocation = []byte("location")

// UnmarshalJSON umarshall json - template of ffjson
func (j *UniprotFeatureAttr) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *UniprotFeatureAttr) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtUniprotFeatureAttrbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtUniprotFeatureAttrnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyUniprotFeatureAttrDescription, kn) {
						currentKey = ffjtUniprotFeatureAttrDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyUniprotFeatureAttrEvidences, kn) {
						currentKey = ffjtUniprotFeatureAttrEvidences
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyUniprotFeatureAttrId, kn) {
						currentKey = ffjtUniprotFeatureAttrId
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyUniprotFeatureAttrLocation, kn) {
						currentKey = ffjtUniprotFeatureAttrLocation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyUniprotFeatureAttrOriginal, kn) {
						currentKey = ffjtUniprotFeatureAttrOriginal
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyUniprotFeatureAttrType, kn) {
						currentKey = ffjtUniprotFeatureAttrType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyUniprotFeatureAttrVariation, kn) {
						currentKey = ffjtUniprotFeatureAttrVariation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyUniprotFeatureAttrLocation, kn) {
					currentKey = ffjtUniprotFeatureAttrLocation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyUniprotFeatureAttrVariation, kn) {
					currentKey = ffjtUniprotFeatureAttrVariation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyUniprotFeatureAttrOriginal, kn) {
					currentKey = ffjtUniprotFeatureAttrOriginal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUniprotFeatureAttrEvidences, kn) {
					currentKey = ffjtUniprotFeatureAttrEvidences
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyUniprotFeatureAttrId, kn) {
					currentKey = ffjtUniprotFeatureAttrId
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUniprotFeatureAttrDescription, kn) {
					currentKey = ffjtUniprotFeatureAttrDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyUniprotFeatureAttrType, kn) {
					currentKey = ffjtUniprotFeatureAttrType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtUniprotFeatureAttrnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtUniprotFeatureAttrType:
					goto handle_Type

				case ffjtUniprotFeatureAttrDescription:
					goto handle_Description

				case ffjtUniprotFeatureAttrId:
					goto handle_Id

				case ffjtUniprotFeatureAttrEvidences:
					goto handle_Evidences

				case ffjtUniprotFeatureAttrOriginal:
					goto handle_Original

				case ffjtUniprotFeatureAttrVariation:
					goto handle_Variation

				case ffjtUniprotFeatureAttrLocation:
					goto handle_Location

				case ffjtUniprotFeatureAttrnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Id:

	/* handler: j.Id type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Id = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Evidences:

	/* handler: j.Evidences type=[]*pbuf.UniprotFeatureEvidence kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Evidences = nil
		} else {

			j.Evidences = []*UniprotFeatureEvidence{}

			wantVal := true

			for {

				var tmpJEvidences *UniprotFeatureEvidence

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJEvidences type=*pbuf.UniprotFeatureEvidence kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						tmpJEvidences = nil

					} else {

						if tmpJEvidences == nil {
							tmpJEvidences = new(UniprotFeatureEvidence)
						}

						err = tmpJEvidences.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Evidences = append(j.Evidences, tmpJEvidences)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Original:

	/* handler: j.Original type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Original = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Variation:

	/* handler: j.Variation type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Variation = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Location:

	/* handler: j.Location type=pbuf.UniLocation kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Location = nil

		} else {

			if j.Location == nil {
				j.Location = new(UniLocation)
			}

			err = j.Location.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *UniprotFeatureEvidence) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *UniprotFeatureEvidence) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.Type) != 0 {
		buf.WriteString(`"type":`)
		fflib.WriteJsonString(buf, string(j.Type))
		buf.WriteByte(',')
	}
	if len(j.Source) != 0 {
		buf.WriteString(`"source":`)
		fflib.WriteJsonString(buf, string(j.Source))
		buf.WriteByte(',')
	}
	if len(j.Id) != 0 {
		buf.WriteString(`"id":`)
		fflib.WriteJsonString(buf, string(j.Id))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtUniprotFeatureEvidencebase = iota
	ffjtUniprotFeatureEvidencenosuchkey

	ffjtUniprotFeatureEvidenceType

	ffjtUniprotFeatureEvidenceSource

	ffjtUniprotFeatureEvidenceId
)

var ffjKeyUniprotFeatureEvidenceType = []byte("type")

var ffjKeyUniprotFeatureEvidenceSource = []byte("source")

var ffjKeyUniprotFeatureEvidenceId = []byte("id")

// UnmarshalJSON umarshall json - template of ffjson
func (j *UniprotFeatureEvidence) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *UniprotFeatureEvidence) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtUniprotFeatureEvidencebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtUniprotFeatureEvidencenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffjKeyUniprotFeatureEvidenceId, kn) {
						currentKey = ffjtUniprotFeatureEvidenceId
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyUniprotFeatureEvidenceSource, kn) {
						currentKey = ffjtUniprotFeatureEvidenceSource
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyUniprotFeatureEvidenceType, kn) {
						currentKey = ffjtUniprotFeatureEvidenceType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyUniprotFeatureEvidenceId, kn) {
					currentKey = ffjtUniprotFeatureEvidenceId
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUniprotFeatureEvidenceSource, kn) {
					currentKey = ffjtUniprotFeatureEvidenceSource
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyUniprotFeatureEvidenceType, kn) {
					currentKey = ffjtUniprotFeatureEvidenceType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtUniprotFeatureEvidencenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtUniprotFeatureEvidenceType:
					goto handle_Type

				case ffjtUniprotFeatureEvidenceSource:
					goto handle_Source

				case ffjtUniprotFeatureEvidenceId:
					goto handle_Id

				case ffjtUniprotFeatureEvidencenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Source:

	/* handler: j.Source type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Source = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Id:

	/* handler: j.Id type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Id = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}
